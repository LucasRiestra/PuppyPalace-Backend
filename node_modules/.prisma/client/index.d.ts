
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type UsuarioPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Usuario"
  objects: {
    cuidador: CuidadorPayload<ExtArgs> | null
    solicitudes: SolicitudPayload<ExtArgs>[]
    comentarios: ComentarioPayload<ExtArgs>[]
    autenticacion: AutenticacionPayload<ExtArgs>[]
    mensajes_enviados: MensajePayload<ExtArgs>[]
    mensajes_recibidos: MensajePayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    nombre: string
    correo_electronico: string
    contrasena: string
    telefono: string | null
    direccion: string | null
    es_cuidador: boolean
    fecha_registro: Date
  }, ExtArgs["result"]["usuario"]>
  composites: {}
}

/**
 * Model Usuario
 * 
 */
export type Usuario = runtime.Types.DefaultSelection<UsuarioPayload>
export type CuidadorPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Cuidador"
  objects: {
    usuario: UsuarioPayload<ExtArgs>
    disponibilidades: DisponibilidadPayload<ExtArgs>[]
    solicitudes: SolicitudPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    usuario_id: string
    experiencia: string | null
    tipo_servicios: string[]
    calificacion_promedio: number | null
    cantidad_servicios: number
  }, ExtArgs["result"]["cuidador"]>
  composites: {}
}

/**
 * Model Cuidador
 * 
 */
export type Cuidador = runtime.Types.DefaultSelection<CuidadorPayload>
export type ServicioPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Servicio"
  objects: {
    disponibilidades: DisponibilidadPayload<ExtArgs>[]
    solicitudes: SolicitudPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    nombre: string
    descripcion: string | null
    precio_base: number | null
  }, ExtArgs["result"]["servicio"]>
  composites: {}
}

/**
 * Model Servicio
 * 
 */
export type Servicio = runtime.Types.DefaultSelection<ServicioPayload>
export type DisponibilidadPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Disponibilidad"
  objects: {
    cuidador: CuidadorPayload<ExtArgs>
    servicio: ServicioPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    cuidador_id: string
    fecha_disponible: Date
    servicio_id: string
  }, ExtArgs["result"]["disponibilidad"]>
  composites: {}
}

/**
 * Model Disponibilidad
 * 
 */
export type Disponibilidad = runtime.Types.DefaultSelection<DisponibilidadPayload>
export type SolicitudPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Solicitud"
  objects: {
    usuario: UsuarioPayload<ExtArgs>
    cuidador: CuidadorPayload<ExtArgs>
    servicio: ServicioPayload<ExtArgs>
    comentario: ComentarioPayload<ExtArgs> | null
    mensajes: MensajePayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    usuario_id: string
    cuidador_id: string
    servicio_id: string
    fecha_solicitada: Date
    estado: string
    fecha_respuesta: Date | null
  }, ExtArgs["result"]["solicitud"]>
  composites: {}
}

/**
 * Model Solicitud
 * 
 */
export type Solicitud = runtime.Types.DefaultSelection<SolicitudPayload>
export type ComentarioPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Comentario"
  objects: {
    solicitud: SolicitudPayload<ExtArgs>
    usuario: UsuarioPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    solicitud_id: string
    usuario_id: string
    calificacion: number
    comentario: string | null
    fecha: Date
  }, ExtArgs["result"]["comentario"]>
  composites: {}
}

/**
 * Model Comentario
 * 
 */
export type Comentario = runtime.Types.DefaultSelection<ComentarioPayload>
export type AutenticacionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Autenticacion"
  objects: {
    usuario: UsuarioPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    usuario_id: string
    token: string
    expiracion: Date
    tipo: string
  }, ExtArgs["result"]["autenticacion"]>
  composites: {}
}

/**
 * Model Autenticacion
 * 
 */
export type Autenticacion = runtime.Types.DefaultSelection<AutenticacionPayload>
export type MensajePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Mensaje"
  objects: {
    remitente: UsuarioPayload<ExtArgs>
    destinatario: UsuarioPayload<ExtArgs>
    solicitud: SolicitudPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    remitente_id: string
    destinatario_id: string
    contenido: string
    fecha: Date
    solicitud_id: string | null
  }, ExtArgs["result"]["mensaje"]>
  composites: {}
}

/**
 * Model Mensaje
 * 
 */
export type Mensaje = runtime.Types.DefaultSelection<MensajePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number }): Promise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.cuidador`: Exposes CRUD operations for the **Cuidador** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cuidadors
    * const cuidadors = await prisma.cuidador.findMany()
    * ```
    */
  get cuidador(): Prisma.CuidadorDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.servicio`: Exposes CRUD operations for the **Servicio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicios
    * const servicios = await prisma.servicio.findMany()
    * ```
    */
  get servicio(): Prisma.ServicioDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.disponibilidad`: Exposes CRUD operations for the **Disponibilidad** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Disponibilidads
    * const disponibilidads = await prisma.disponibilidad.findMany()
    * ```
    */
  get disponibilidad(): Prisma.DisponibilidadDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.solicitud`: Exposes CRUD operations for the **Solicitud** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Solicituds
    * const solicituds = await prisma.solicitud.findMany()
    * ```
    */
  get solicitud(): Prisma.SolicitudDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.comentario`: Exposes CRUD operations for the **Comentario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comentarios
    * const comentarios = await prisma.comentario.findMany()
    * ```
    */
  get comentario(): Prisma.ComentarioDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.autenticacion`: Exposes CRUD operations for the **Autenticacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Autenticacions
    * const autenticacions = await prisma.autenticacion.findMany()
    * ```
    */
  get autenticacion(): Prisma.AutenticacionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.mensaje`: Exposes CRUD operations for the **Mensaje** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mensajes
    * const mensajes = await prisma.mensaje.findMany()
    * ```
    */
  get mensaje(): Prisma.MensajeDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.16.2
   * Query Engine version: 4bc8b6e1b66cb932731fb1bdbbc550d1e010de81
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Usuario: 'Usuario',
    Cuidador: 'Cuidador',
    Servicio: 'Servicio',
    Disponibilidad: 'Disponibilidad',
    Solicitud: 'Solicitud',
    Comentario: 'Comentario',
    Autenticacion: 'Autenticacion',
    Mensaje: 'Mensaje'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'usuario' | 'cuidador' | 'servicio' | 'disponibilidad' | 'solicitud' | 'comentario' | 'autenticacion' | 'mensaje'
      txIsolationLevel: never
    },
    model: {
      Usuario: {
        payload: UsuarioPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UsuarioFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.UsuarioAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>,
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Cuidador: {
        payload: CuidadorPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.CuidadorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CuidadorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CuidadorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CuidadorPayload>
          }
          findFirst: {
            args: Prisma.CuidadorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CuidadorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CuidadorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CuidadorPayload>
          }
          findMany: {
            args: Prisma.CuidadorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CuidadorPayload>[]
          }
          create: {
            args: Prisma.CuidadorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CuidadorPayload>
          }
          createMany: {
            args: Prisma.CuidadorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CuidadorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CuidadorPayload>
          }
          update: {
            args: Prisma.CuidadorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CuidadorPayload>
          }
          deleteMany: {
            args: Prisma.CuidadorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CuidadorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CuidadorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CuidadorPayload>
          }
          aggregate: {
            args: Prisma.CuidadorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCuidador>
          }
          groupBy: {
            args: Prisma.CuidadorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CuidadorGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CuidadorFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.CuidadorAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.CuidadorCountArgs<ExtArgs>,
            result: $Utils.Optional<CuidadorCountAggregateOutputType> | number
          }
        }
      }
      Servicio: {
        payload: ServicioPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ServicioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicioPayload>
          }
          findFirst: {
            args: Prisma.ServicioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicioPayload>
          }
          findMany: {
            args: Prisma.ServicioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicioPayload>[]
          }
          create: {
            args: Prisma.ServicioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicioPayload>
          }
          createMany: {
            args: Prisma.ServicioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ServicioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicioPayload>
          }
          update: {
            args: Prisma.ServicioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicioPayload>
          }
          deleteMany: {
            args: Prisma.ServicioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ServicioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ServicioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicioPayload>
          }
          aggregate: {
            args: Prisma.ServicioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServicio>
          }
          groupBy: {
            args: Prisma.ServicioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServicioGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ServicioFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.ServicioAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.ServicioCountArgs<ExtArgs>,
            result: $Utils.Optional<ServicioCountAggregateOutputType> | number
          }
        }
      }
      Disponibilidad: {
        payload: DisponibilidadPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.DisponibilidadFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DisponibilidadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisponibilidadFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DisponibilidadPayload>
          }
          findFirst: {
            args: Prisma.DisponibilidadFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DisponibilidadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisponibilidadFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DisponibilidadPayload>
          }
          findMany: {
            args: Prisma.DisponibilidadFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DisponibilidadPayload>[]
          }
          create: {
            args: Prisma.DisponibilidadCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DisponibilidadPayload>
          }
          createMany: {
            args: Prisma.DisponibilidadCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DisponibilidadDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DisponibilidadPayload>
          }
          update: {
            args: Prisma.DisponibilidadUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DisponibilidadPayload>
          }
          deleteMany: {
            args: Prisma.DisponibilidadDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DisponibilidadUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DisponibilidadUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DisponibilidadPayload>
          }
          aggregate: {
            args: Prisma.DisponibilidadAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDisponibilidad>
          }
          groupBy: {
            args: Prisma.DisponibilidadGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DisponibilidadGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DisponibilidadFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.DisponibilidadAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.DisponibilidadCountArgs<ExtArgs>,
            result: $Utils.Optional<DisponibilidadCountAggregateOutputType> | number
          }
        }
      }
      Solicitud: {
        payload: SolicitudPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.SolicitudFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SolicitudPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SolicitudFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SolicitudPayload>
          }
          findFirst: {
            args: Prisma.SolicitudFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SolicitudPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SolicitudFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SolicitudPayload>
          }
          findMany: {
            args: Prisma.SolicitudFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SolicitudPayload>[]
          }
          create: {
            args: Prisma.SolicitudCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SolicitudPayload>
          }
          createMany: {
            args: Prisma.SolicitudCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SolicitudDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SolicitudPayload>
          }
          update: {
            args: Prisma.SolicitudUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SolicitudPayload>
          }
          deleteMany: {
            args: Prisma.SolicitudDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SolicitudUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SolicitudUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SolicitudPayload>
          }
          aggregate: {
            args: Prisma.SolicitudAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSolicitud>
          }
          groupBy: {
            args: Prisma.SolicitudGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SolicitudGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SolicitudFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.SolicitudAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.SolicitudCountArgs<ExtArgs>,
            result: $Utils.Optional<SolicitudCountAggregateOutputType> | number
          }
        }
      }
      Comentario: {
        payload: ComentarioPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ComentarioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ComentarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComentarioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ComentarioPayload>
          }
          findFirst: {
            args: Prisma.ComentarioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ComentarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComentarioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ComentarioPayload>
          }
          findMany: {
            args: Prisma.ComentarioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ComentarioPayload>[]
          }
          create: {
            args: Prisma.ComentarioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ComentarioPayload>
          }
          createMany: {
            args: Prisma.ComentarioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ComentarioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ComentarioPayload>
          }
          update: {
            args: Prisma.ComentarioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ComentarioPayload>
          }
          deleteMany: {
            args: Prisma.ComentarioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ComentarioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ComentarioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ComentarioPayload>
          }
          aggregate: {
            args: Prisma.ComentarioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComentario>
          }
          groupBy: {
            args: Prisma.ComentarioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ComentarioGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ComentarioFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.ComentarioAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.ComentarioCountArgs<ExtArgs>,
            result: $Utils.Optional<ComentarioCountAggregateOutputType> | number
          }
        }
      }
      Autenticacion: {
        payload: AutenticacionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AutenticacionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AutenticacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutenticacionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AutenticacionPayload>
          }
          findFirst: {
            args: Prisma.AutenticacionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AutenticacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutenticacionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AutenticacionPayload>
          }
          findMany: {
            args: Prisma.AutenticacionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AutenticacionPayload>[]
          }
          create: {
            args: Prisma.AutenticacionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AutenticacionPayload>
          }
          createMany: {
            args: Prisma.AutenticacionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AutenticacionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AutenticacionPayload>
          }
          update: {
            args: Prisma.AutenticacionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AutenticacionPayload>
          }
          deleteMany: {
            args: Prisma.AutenticacionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AutenticacionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AutenticacionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AutenticacionPayload>
          }
          aggregate: {
            args: Prisma.AutenticacionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAutenticacion>
          }
          groupBy: {
            args: Prisma.AutenticacionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AutenticacionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AutenticacionFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.AutenticacionAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.AutenticacionCountArgs<ExtArgs>,
            result: $Utils.Optional<AutenticacionCountAggregateOutputType> | number
          }
        }
      }
      Mensaje: {
        payload: MensajePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.MensajeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MensajePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MensajeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MensajePayload>
          }
          findFirst: {
            args: Prisma.MensajeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MensajePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MensajeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MensajePayload>
          }
          findMany: {
            args: Prisma.MensajeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MensajePayload>[]
          }
          create: {
            args: Prisma.MensajeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MensajePayload>
          }
          createMany: {
            args: Prisma.MensajeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MensajeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MensajePayload>
          }
          update: {
            args: Prisma.MensajeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MensajePayload>
          }
          deleteMany: {
            args: Prisma.MensajeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MensajeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MensajeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MensajePayload>
          }
          aggregate: {
            args: Prisma.MensajeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMensaje>
          }
          groupBy: {
            args: Prisma.MensajeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MensajeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MensajeFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.MensajeAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.MensajeCountArgs<ExtArgs>,
            result: $Utils.Optional<MensajeCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */


  export type UsuarioCountOutputType = {
    solicitudes: number
    comentarios: number
    autenticacion: number
    mensajes_enviados: number
    mensajes_recibidos: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    solicitudes?: boolean | UsuarioCountOutputTypeCountSolicitudesArgs
    comentarios?: boolean | UsuarioCountOutputTypeCountComentariosArgs
    autenticacion?: boolean | UsuarioCountOutputTypeCountAutenticacionArgs
    mensajes_enviados?: boolean | UsuarioCountOutputTypeCountMensajes_enviadosArgs
    mensajes_recibidos?: boolean | UsuarioCountOutputTypeCountMensajes_recibidosArgs
  }

  // Custom InputTypes

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountSolicitudesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SolicitudWhereInput
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountComentariosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ComentarioWhereInput
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountAutenticacionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AutenticacionWhereInput
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountMensajes_enviadosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MensajeWhereInput
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountMensajes_recibidosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MensajeWhereInput
  }



  /**
   * Count Type CuidadorCountOutputType
   */


  export type CuidadorCountOutputType = {
    disponibilidades: number
    solicitudes: number
  }

  export type CuidadorCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    disponibilidades?: boolean | CuidadorCountOutputTypeCountDisponibilidadesArgs
    solicitudes?: boolean | CuidadorCountOutputTypeCountSolicitudesArgs
  }

  // Custom InputTypes

  /**
   * CuidadorCountOutputType without action
   */
  export type CuidadorCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CuidadorCountOutputType
     */
    select?: CuidadorCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CuidadorCountOutputType without action
   */
  export type CuidadorCountOutputTypeCountDisponibilidadesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DisponibilidadWhereInput
  }


  /**
   * CuidadorCountOutputType without action
   */
  export type CuidadorCountOutputTypeCountSolicitudesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SolicitudWhereInput
  }



  /**
   * Count Type ServicioCountOutputType
   */


  export type ServicioCountOutputType = {
    disponibilidades: number
    solicitudes: number
  }

  export type ServicioCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    disponibilidades?: boolean | ServicioCountOutputTypeCountDisponibilidadesArgs
    solicitudes?: boolean | ServicioCountOutputTypeCountSolicitudesArgs
  }

  // Custom InputTypes

  /**
   * ServicioCountOutputType without action
   */
  export type ServicioCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioCountOutputType
     */
    select?: ServicioCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ServicioCountOutputType without action
   */
  export type ServicioCountOutputTypeCountDisponibilidadesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DisponibilidadWhereInput
  }


  /**
   * ServicioCountOutputType without action
   */
  export type ServicioCountOutputTypeCountSolicitudesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SolicitudWhereInput
  }



  /**
   * Count Type SolicitudCountOutputType
   */


  export type SolicitudCountOutputType = {
    mensajes: number
  }

  export type SolicitudCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    mensajes?: boolean | SolicitudCountOutputTypeCountMensajesArgs
  }

  // Custom InputTypes

  /**
   * SolicitudCountOutputType without action
   */
  export type SolicitudCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitudCountOutputType
     */
    select?: SolicitudCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SolicitudCountOutputType without action
   */
  export type SolicitudCountOutputTypeCountMensajesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MensajeWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Usuario
   */


  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    correo_electronico: string | null
    contrasena: string | null
    telefono: string | null
    direccion: string | null
    es_cuidador: boolean | null
    fecha_registro: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    correo_electronico: string | null
    contrasena: string | null
    telefono: string | null
    direccion: string | null
    es_cuidador: boolean | null
    fecha_registro: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nombre: number
    correo_electronico: number
    contrasena: number
    telefono: number
    direccion: number
    es_cuidador: number
    fecha_registro: number
    _all: number
  }


  export type UsuarioMinAggregateInputType = {
    id?: true
    nombre?: true
    correo_electronico?: true
    contrasena?: true
    telefono?: true
    direccion?: true
    es_cuidador?: true
    fecha_registro?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nombre?: true
    correo_electronico?: true
    contrasena?: true
    telefono?: true
    direccion?: true
    es_cuidador?: true
    fecha_registro?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nombre?: true
    correo_electronico?: true
    contrasena?: true
    telefono?: true
    direccion?: true
    es_cuidador?: true
    fecha_registro?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: Enumerable<UsuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: Enumerable<UsuarioOrderByWithAggregationInput>
    by: UsuarioScalarFieldEnum[]
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }


  export type UsuarioGroupByOutputType = {
    id: string
    nombre: string
    correo_electronico: string
    contrasena: string
    telefono: string | null
    direccion: string | null
    es_cuidador: boolean
    fecha_registro: Date
    _count: UsuarioCountAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    correo_electronico?: boolean
    contrasena?: boolean
    telefono?: boolean
    direccion?: boolean
    es_cuidador?: boolean
    fecha_registro?: boolean
    cuidador?: boolean | CuidadorArgs<ExtArgs>
    solicitudes?: boolean | Usuario$solicitudesArgs<ExtArgs>
    comentarios?: boolean | Usuario$comentariosArgs<ExtArgs>
    autenticacion?: boolean | Usuario$autenticacionArgs<ExtArgs>
    mensajes_enviados?: boolean | Usuario$mensajes_enviadosArgs<ExtArgs>
    mensajes_recibidos?: boolean | Usuario$mensajes_recibidosArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    nombre?: boolean
    correo_electronico?: boolean
    contrasena?: boolean
    telefono?: boolean
    direccion?: boolean
    es_cuidador?: boolean
    fecha_registro?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    cuidador?: boolean | CuidadorArgs<ExtArgs>
    solicitudes?: boolean | Usuario$solicitudesArgs<ExtArgs>
    comentarios?: boolean | Usuario$comentariosArgs<ExtArgs>
    autenticacion?: boolean | Usuario$autenticacionArgs<ExtArgs>
    mensajes_enviados?: boolean | Usuario$mensajes_enviadosArgs<ExtArgs>
    mensajes_recibidos?: boolean | Usuario$mensajes_recibidosArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeArgs<ExtArgs>
  }


  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioArgs> = $Types.GetResult<UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsuarioFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Usuario'> extends True ? Prisma__UsuarioClient<$Types.GetResult<UsuarioPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UsuarioClient<$Types.GetResult<UsuarioPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Types.GetResult<UsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsuarioFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Usuario'> extends True ? Prisma__UsuarioClient<$Types.GetResult<UsuarioPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UsuarioClient<$Types.GetResult<UsuarioPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Types.GetResult<UsuarioPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UsuarioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UsuarioPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
    **/
    create<T extends UsuarioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Types.GetResult<UsuarioPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Usuarios.
     *     @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     *     @example
     *     // Create many Usuarios
     *     const usuario = await prisma.usuario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsuarioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
    **/
    delete<T extends UsuarioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Types.GetResult<UsuarioPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsuarioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Types.GetResult<UsuarioPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsuarioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsuarioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
    **/
    upsert<T extends UsuarioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Types.GetResult<UsuarioPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * @param {UsuarioFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const usuario = await prisma.usuario.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: UsuarioFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Usuario.
     * @param {UsuarioAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const usuario = await prisma.usuario.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: UsuarioAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    cuidador<T extends CuidadorArgs<ExtArgs> = {}>(args?: Subset<T, CuidadorArgs<ExtArgs>>): Prisma__CuidadorClient<$Types.GetResult<CuidadorPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    solicitudes<T extends Usuario$solicitudesArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$solicitudesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<SolicitudPayload<ExtArgs>, T, 'findMany', never>| Null>;

    comentarios<T extends Usuario$comentariosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$comentariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ComentarioPayload<ExtArgs>, T, 'findMany', never>| Null>;

    autenticacion<T extends Usuario$autenticacionArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$autenticacionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AutenticacionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    mensajes_enviados<T extends Usuario$mensajes_enviadosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$mensajes_enviadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<MensajePayload<ExtArgs>, T, 'findMany', never>| Null>;

    mensajes_recibidos<T extends Usuario$mensajes_recibidosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$mensajes_recibidosArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<MensajePayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Usuario base type for findUnique actions
   */
  export type UsuarioFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUnique
   */
  export interface UsuarioFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UsuarioFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario base type for findFirst actions
   */
  export type UsuarioFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: Enumerable<UsuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }

  /**
   * Usuario findFirst
   */
  export interface UsuarioFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UsuarioFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: Enumerable<UsuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }


  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: Enumerable<UsuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }


  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }


  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: Enumerable<UsuarioCreateManyInput>
  }


  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }


  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }


  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }


  /**
   * Usuario findRaw
   */
  export type UsuarioFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Usuario aggregateRaw
   */
  export type UsuarioAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Usuario.solicitudes
   */
  export type Usuario$solicitudesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solicitud
     */
    select?: SolicitudSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitudInclude<ExtArgs> | null
    where?: SolicitudWhereInput
    orderBy?: Enumerable<SolicitudOrderByWithRelationInput>
    cursor?: SolicitudWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SolicitudScalarFieldEnum>
  }


  /**
   * Usuario.comentarios
   */
  export type Usuario$comentariosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComentarioInclude<ExtArgs> | null
    where?: ComentarioWhereInput
    orderBy?: Enumerable<ComentarioOrderByWithRelationInput>
    cursor?: ComentarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ComentarioScalarFieldEnum>
  }


  /**
   * Usuario.autenticacion
   */
  export type Usuario$autenticacionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Autenticacion
     */
    select?: AutenticacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AutenticacionInclude<ExtArgs> | null
    where?: AutenticacionWhereInput
    orderBy?: Enumerable<AutenticacionOrderByWithRelationInput>
    cursor?: AutenticacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AutenticacionScalarFieldEnum>
  }


  /**
   * Usuario.mensajes_enviados
   */
  export type Usuario$mensajes_enviadosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensajeInclude<ExtArgs> | null
    where?: MensajeWhereInput
    orderBy?: Enumerable<MensajeOrderByWithRelationInput>
    cursor?: MensajeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MensajeScalarFieldEnum>
  }


  /**
   * Usuario.mensajes_recibidos
   */
  export type Usuario$mensajes_recibidosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensajeInclude<ExtArgs> | null
    where?: MensajeWhereInput
    orderBy?: Enumerable<MensajeOrderByWithRelationInput>
    cursor?: MensajeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MensajeScalarFieldEnum>
  }


  /**
   * Usuario without action
   */
  export type UsuarioArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
  }



  /**
   * Model Cuidador
   */


  export type AggregateCuidador = {
    _count: CuidadorCountAggregateOutputType | null
    _avg: CuidadorAvgAggregateOutputType | null
    _sum: CuidadorSumAggregateOutputType | null
    _min: CuidadorMinAggregateOutputType | null
    _max: CuidadorMaxAggregateOutputType | null
  }

  export type CuidadorAvgAggregateOutputType = {
    calificacion_promedio: number | null
    cantidad_servicios: number | null
  }

  export type CuidadorSumAggregateOutputType = {
    calificacion_promedio: number | null
    cantidad_servicios: number | null
  }

  export type CuidadorMinAggregateOutputType = {
    id: string | null
    usuario_id: string | null
    experiencia: string | null
    calificacion_promedio: number | null
    cantidad_servicios: number | null
  }

  export type CuidadorMaxAggregateOutputType = {
    id: string | null
    usuario_id: string | null
    experiencia: string | null
    calificacion_promedio: number | null
    cantidad_servicios: number | null
  }

  export type CuidadorCountAggregateOutputType = {
    id: number
    usuario_id: number
    experiencia: number
    tipo_servicios: number
    calificacion_promedio: number
    cantidad_servicios: number
    _all: number
  }


  export type CuidadorAvgAggregateInputType = {
    calificacion_promedio?: true
    cantidad_servicios?: true
  }

  export type CuidadorSumAggregateInputType = {
    calificacion_promedio?: true
    cantidad_servicios?: true
  }

  export type CuidadorMinAggregateInputType = {
    id?: true
    usuario_id?: true
    experiencia?: true
    calificacion_promedio?: true
    cantidad_servicios?: true
  }

  export type CuidadorMaxAggregateInputType = {
    id?: true
    usuario_id?: true
    experiencia?: true
    calificacion_promedio?: true
    cantidad_servicios?: true
  }

  export type CuidadorCountAggregateInputType = {
    id?: true
    usuario_id?: true
    experiencia?: true
    tipo_servicios?: true
    calificacion_promedio?: true
    cantidad_servicios?: true
    _all?: true
  }

  export type CuidadorAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cuidador to aggregate.
     */
    where?: CuidadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuidadors to fetch.
     */
    orderBy?: Enumerable<CuidadorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CuidadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuidadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuidadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cuidadors
    **/
    _count?: true | CuidadorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CuidadorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CuidadorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CuidadorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CuidadorMaxAggregateInputType
  }

  export type GetCuidadorAggregateType<T extends CuidadorAggregateArgs> = {
        [P in keyof T & keyof AggregateCuidador]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCuidador[P]>
      : GetScalarType<T[P], AggregateCuidador[P]>
  }




  export type CuidadorGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CuidadorWhereInput
    orderBy?: Enumerable<CuidadorOrderByWithAggregationInput>
    by: CuidadorScalarFieldEnum[]
    having?: CuidadorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CuidadorCountAggregateInputType | true
    _avg?: CuidadorAvgAggregateInputType
    _sum?: CuidadorSumAggregateInputType
    _min?: CuidadorMinAggregateInputType
    _max?: CuidadorMaxAggregateInputType
  }


  export type CuidadorGroupByOutputType = {
    id: string
    usuario_id: string
    experiencia: string | null
    tipo_servicios: string[]
    calificacion_promedio: number | null
    cantidad_servicios: number
    _count: CuidadorCountAggregateOutputType | null
    _avg: CuidadorAvgAggregateOutputType | null
    _sum: CuidadorSumAggregateOutputType | null
    _min: CuidadorMinAggregateOutputType | null
    _max: CuidadorMaxAggregateOutputType | null
  }

  type GetCuidadorGroupByPayload<T extends CuidadorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CuidadorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CuidadorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CuidadorGroupByOutputType[P]>
            : GetScalarType<T[P], CuidadorGroupByOutputType[P]>
        }
      >
    >


  export type CuidadorSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    experiencia?: boolean
    tipo_servicios?: boolean
    calificacion_promedio?: boolean
    cantidad_servicios?: boolean
    usuario?: boolean | UsuarioArgs<ExtArgs>
    disponibilidades?: boolean | Cuidador$disponibilidadesArgs<ExtArgs>
    solicitudes?: boolean | Cuidador$solicitudesArgs<ExtArgs>
    _count?: boolean | CuidadorCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["cuidador"]>

  export type CuidadorSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    experiencia?: boolean
    tipo_servicios?: boolean
    calificacion_promedio?: boolean
    cantidad_servicios?: boolean
  }

  export type CuidadorInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioArgs<ExtArgs>
    disponibilidades?: boolean | Cuidador$disponibilidadesArgs<ExtArgs>
    solicitudes?: boolean | Cuidador$solicitudesArgs<ExtArgs>
    _count?: boolean | CuidadorCountOutputTypeArgs<ExtArgs>
  }


  type CuidadorGetPayload<S extends boolean | null | undefined | CuidadorArgs> = $Types.GetResult<CuidadorPayload, S>

  type CuidadorCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CuidadorFindManyArgs, 'select' | 'include'> & {
      select?: CuidadorCountAggregateInputType | true
    }

  export interface CuidadorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cuidador'], meta: { name: 'Cuidador' } }
    /**
     * Find zero or one Cuidador that matches the filter.
     * @param {CuidadorFindUniqueArgs} args - Arguments to find a Cuidador
     * @example
     * // Get one Cuidador
     * const cuidador = await prisma.cuidador.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CuidadorFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CuidadorFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Cuidador'> extends True ? Prisma__CuidadorClient<$Types.GetResult<CuidadorPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__CuidadorClient<$Types.GetResult<CuidadorPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Cuidador that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CuidadorFindUniqueOrThrowArgs} args - Arguments to find a Cuidador
     * @example
     * // Get one Cuidador
     * const cuidador = await prisma.cuidador.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CuidadorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CuidadorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CuidadorClient<$Types.GetResult<CuidadorPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Cuidador that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuidadorFindFirstArgs} args - Arguments to find a Cuidador
     * @example
     * // Get one Cuidador
     * const cuidador = await prisma.cuidador.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CuidadorFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CuidadorFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Cuidador'> extends True ? Prisma__CuidadorClient<$Types.GetResult<CuidadorPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__CuidadorClient<$Types.GetResult<CuidadorPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Cuidador that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuidadorFindFirstOrThrowArgs} args - Arguments to find a Cuidador
     * @example
     * // Get one Cuidador
     * const cuidador = await prisma.cuidador.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CuidadorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CuidadorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CuidadorClient<$Types.GetResult<CuidadorPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Cuidadors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuidadorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cuidadors
     * const cuidadors = await prisma.cuidador.findMany()
     * 
     * // Get first 10 Cuidadors
     * const cuidadors = await prisma.cuidador.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cuidadorWithIdOnly = await prisma.cuidador.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CuidadorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CuidadorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CuidadorPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Cuidador.
     * @param {CuidadorCreateArgs} args - Arguments to create a Cuidador.
     * @example
     * // Create one Cuidador
     * const Cuidador = await prisma.cuidador.create({
     *   data: {
     *     // ... data to create a Cuidador
     *   }
     * })
     * 
    **/
    create<T extends CuidadorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CuidadorCreateArgs<ExtArgs>>
    ): Prisma__CuidadorClient<$Types.GetResult<CuidadorPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Cuidadors.
     *     @param {CuidadorCreateManyArgs} args - Arguments to create many Cuidadors.
     *     @example
     *     // Create many Cuidadors
     *     const cuidador = await prisma.cuidador.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CuidadorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CuidadorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cuidador.
     * @param {CuidadorDeleteArgs} args - Arguments to delete one Cuidador.
     * @example
     * // Delete one Cuidador
     * const Cuidador = await prisma.cuidador.delete({
     *   where: {
     *     // ... filter to delete one Cuidador
     *   }
     * })
     * 
    **/
    delete<T extends CuidadorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CuidadorDeleteArgs<ExtArgs>>
    ): Prisma__CuidadorClient<$Types.GetResult<CuidadorPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Cuidador.
     * @param {CuidadorUpdateArgs} args - Arguments to update one Cuidador.
     * @example
     * // Update one Cuidador
     * const cuidador = await prisma.cuidador.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CuidadorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CuidadorUpdateArgs<ExtArgs>>
    ): Prisma__CuidadorClient<$Types.GetResult<CuidadorPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Cuidadors.
     * @param {CuidadorDeleteManyArgs} args - Arguments to filter Cuidadors to delete.
     * @example
     * // Delete a few Cuidadors
     * const { count } = await prisma.cuidador.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CuidadorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CuidadorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cuidadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuidadorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cuidadors
     * const cuidador = await prisma.cuidador.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CuidadorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CuidadorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cuidador.
     * @param {CuidadorUpsertArgs} args - Arguments to update or create a Cuidador.
     * @example
     * // Update or create a Cuidador
     * const cuidador = await prisma.cuidador.upsert({
     *   create: {
     *     // ... data to create a Cuidador
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cuidador we want to update
     *   }
     * })
    **/
    upsert<T extends CuidadorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CuidadorUpsertArgs<ExtArgs>>
    ): Prisma__CuidadorClient<$Types.GetResult<CuidadorPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Find zero or more Cuidadors that matches the filter.
     * @param {CuidadorFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const cuidador = await prisma.cuidador.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: CuidadorFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Cuidador.
     * @param {CuidadorAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const cuidador = await prisma.cuidador.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: CuidadorAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Cuidadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuidadorCountArgs} args - Arguments to filter Cuidadors to count.
     * @example
     * // Count the number of Cuidadors
     * const count = await prisma.cuidador.count({
     *   where: {
     *     // ... the filter for the Cuidadors we want to count
     *   }
     * })
    **/
    count<T extends CuidadorCountArgs>(
      args?: Subset<T, CuidadorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CuidadorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cuidador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuidadorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CuidadorAggregateArgs>(args: Subset<T, CuidadorAggregateArgs>): Prisma.PrismaPromise<GetCuidadorAggregateType<T>>

    /**
     * Group by Cuidador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuidadorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CuidadorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CuidadorGroupByArgs['orderBy'] }
        : { orderBy?: CuidadorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CuidadorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCuidadorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Cuidador.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CuidadorClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    usuario<T extends UsuarioArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioArgs<ExtArgs>>): Prisma__UsuarioClient<$Types.GetResult<UsuarioPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    disponibilidades<T extends Cuidador$disponibilidadesArgs<ExtArgs> = {}>(args?: Subset<T, Cuidador$disponibilidadesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DisponibilidadPayload<ExtArgs>, T, 'findMany', never>| Null>;

    solicitudes<T extends Cuidador$solicitudesArgs<ExtArgs> = {}>(args?: Subset<T, Cuidador$solicitudesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<SolicitudPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Cuidador base type for findUnique actions
   */
  export type CuidadorFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuidador
     */
    select?: CuidadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CuidadorInclude<ExtArgs> | null
    /**
     * Filter, which Cuidador to fetch.
     */
    where: CuidadorWhereUniqueInput
  }

  /**
   * Cuidador findUnique
   */
  export interface CuidadorFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CuidadorFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Cuidador findUniqueOrThrow
   */
  export type CuidadorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuidador
     */
    select?: CuidadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CuidadorInclude<ExtArgs> | null
    /**
     * Filter, which Cuidador to fetch.
     */
    where: CuidadorWhereUniqueInput
  }


  /**
   * Cuidador base type for findFirst actions
   */
  export type CuidadorFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuidador
     */
    select?: CuidadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CuidadorInclude<ExtArgs> | null
    /**
     * Filter, which Cuidador to fetch.
     */
    where?: CuidadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuidadors to fetch.
     */
    orderBy?: Enumerable<CuidadorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cuidadors.
     */
    cursor?: CuidadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuidadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuidadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cuidadors.
     */
    distinct?: Enumerable<CuidadorScalarFieldEnum>
  }

  /**
   * Cuidador findFirst
   */
  export interface CuidadorFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CuidadorFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Cuidador findFirstOrThrow
   */
  export type CuidadorFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuidador
     */
    select?: CuidadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CuidadorInclude<ExtArgs> | null
    /**
     * Filter, which Cuidador to fetch.
     */
    where?: CuidadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuidadors to fetch.
     */
    orderBy?: Enumerable<CuidadorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cuidadors.
     */
    cursor?: CuidadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuidadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuidadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cuidadors.
     */
    distinct?: Enumerable<CuidadorScalarFieldEnum>
  }


  /**
   * Cuidador findMany
   */
  export type CuidadorFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuidador
     */
    select?: CuidadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CuidadorInclude<ExtArgs> | null
    /**
     * Filter, which Cuidadors to fetch.
     */
    where?: CuidadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuidadors to fetch.
     */
    orderBy?: Enumerable<CuidadorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cuidadors.
     */
    cursor?: CuidadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuidadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuidadors.
     */
    skip?: number
    distinct?: Enumerable<CuidadorScalarFieldEnum>
  }


  /**
   * Cuidador create
   */
  export type CuidadorCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuidador
     */
    select?: CuidadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CuidadorInclude<ExtArgs> | null
    /**
     * The data needed to create a Cuidador.
     */
    data: XOR<CuidadorCreateInput, CuidadorUncheckedCreateInput>
  }


  /**
   * Cuidador createMany
   */
  export type CuidadorCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cuidadors.
     */
    data: Enumerable<CuidadorCreateManyInput>
  }


  /**
   * Cuidador update
   */
  export type CuidadorUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuidador
     */
    select?: CuidadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CuidadorInclude<ExtArgs> | null
    /**
     * The data needed to update a Cuidador.
     */
    data: XOR<CuidadorUpdateInput, CuidadorUncheckedUpdateInput>
    /**
     * Choose, which Cuidador to update.
     */
    where: CuidadorWhereUniqueInput
  }


  /**
   * Cuidador updateMany
   */
  export type CuidadorUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cuidadors.
     */
    data: XOR<CuidadorUpdateManyMutationInput, CuidadorUncheckedUpdateManyInput>
    /**
     * Filter which Cuidadors to update
     */
    where?: CuidadorWhereInput
  }


  /**
   * Cuidador upsert
   */
  export type CuidadorUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuidador
     */
    select?: CuidadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CuidadorInclude<ExtArgs> | null
    /**
     * The filter to search for the Cuidador to update in case it exists.
     */
    where: CuidadorWhereUniqueInput
    /**
     * In case the Cuidador found by the `where` argument doesn't exist, create a new Cuidador with this data.
     */
    create: XOR<CuidadorCreateInput, CuidadorUncheckedCreateInput>
    /**
     * In case the Cuidador was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CuidadorUpdateInput, CuidadorUncheckedUpdateInput>
  }


  /**
   * Cuidador delete
   */
  export type CuidadorDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuidador
     */
    select?: CuidadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CuidadorInclude<ExtArgs> | null
    /**
     * Filter which Cuidador to delete.
     */
    where: CuidadorWhereUniqueInput
  }


  /**
   * Cuidador deleteMany
   */
  export type CuidadorDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cuidadors to delete
     */
    where?: CuidadorWhereInput
  }


  /**
   * Cuidador findRaw
   */
  export type CuidadorFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Cuidador aggregateRaw
   */
  export type CuidadorAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Cuidador.disponibilidades
   */
  export type Cuidador$disponibilidadesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disponibilidad
     */
    select?: DisponibilidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DisponibilidadInclude<ExtArgs> | null
    where?: DisponibilidadWhereInput
    orderBy?: Enumerable<DisponibilidadOrderByWithRelationInput>
    cursor?: DisponibilidadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DisponibilidadScalarFieldEnum>
  }


  /**
   * Cuidador.solicitudes
   */
  export type Cuidador$solicitudesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solicitud
     */
    select?: SolicitudSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitudInclude<ExtArgs> | null
    where?: SolicitudWhereInput
    orderBy?: Enumerable<SolicitudOrderByWithRelationInput>
    cursor?: SolicitudWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SolicitudScalarFieldEnum>
  }


  /**
   * Cuidador without action
   */
  export type CuidadorArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuidador
     */
    select?: CuidadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CuidadorInclude<ExtArgs> | null
  }



  /**
   * Model Servicio
   */


  export type AggregateServicio = {
    _count: ServicioCountAggregateOutputType | null
    _avg: ServicioAvgAggregateOutputType | null
    _sum: ServicioSumAggregateOutputType | null
    _min: ServicioMinAggregateOutputType | null
    _max: ServicioMaxAggregateOutputType | null
  }

  export type ServicioAvgAggregateOutputType = {
    precio_base: number | null
  }

  export type ServicioSumAggregateOutputType = {
    precio_base: number | null
  }

  export type ServicioMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    precio_base: number | null
  }

  export type ServicioMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    precio_base: number | null
  }

  export type ServicioCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    precio_base: number
    _all: number
  }


  export type ServicioAvgAggregateInputType = {
    precio_base?: true
  }

  export type ServicioSumAggregateInputType = {
    precio_base?: true
  }

  export type ServicioMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    precio_base?: true
  }

  export type ServicioMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    precio_base?: true
  }

  export type ServicioCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    precio_base?: true
    _all?: true
  }

  export type ServicioAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Servicio to aggregate.
     */
    where?: ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: Enumerable<ServicioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Servicios
    **/
    _count?: true | ServicioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicioMaxAggregateInputType
  }

  export type GetServicioAggregateType<T extends ServicioAggregateArgs> = {
        [P in keyof T & keyof AggregateServicio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicio[P]>
      : GetScalarType<T[P], AggregateServicio[P]>
  }




  export type ServicioGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServicioWhereInput
    orderBy?: Enumerable<ServicioOrderByWithAggregationInput>
    by: ServicioScalarFieldEnum[]
    having?: ServicioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicioCountAggregateInputType | true
    _avg?: ServicioAvgAggregateInputType
    _sum?: ServicioSumAggregateInputType
    _min?: ServicioMinAggregateInputType
    _max?: ServicioMaxAggregateInputType
  }


  export type ServicioGroupByOutputType = {
    id: string
    nombre: string
    descripcion: string | null
    precio_base: number | null
    _count: ServicioCountAggregateOutputType | null
    _avg: ServicioAvgAggregateOutputType | null
    _sum: ServicioSumAggregateOutputType | null
    _min: ServicioMinAggregateOutputType | null
    _max: ServicioMaxAggregateOutputType | null
  }

  type GetServicioGroupByPayload<T extends ServicioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServicioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicioGroupByOutputType[P]>
            : GetScalarType<T[P], ServicioGroupByOutputType[P]>
        }
      >
    >


  export type ServicioSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    precio_base?: boolean
    disponibilidades?: boolean | Servicio$disponibilidadesArgs<ExtArgs>
    solicitudes?: boolean | Servicio$solicitudesArgs<ExtArgs>
    _count?: boolean | ServicioCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["servicio"]>

  export type ServicioSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    precio_base?: boolean
  }

  export type ServicioInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    disponibilidades?: boolean | Servicio$disponibilidadesArgs<ExtArgs>
    solicitudes?: boolean | Servicio$solicitudesArgs<ExtArgs>
    _count?: boolean | ServicioCountOutputTypeArgs<ExtArgs>
  }


  type ServicioGetPayload<S extends boolean | null | undefined | ServicioArgs> = $Types.GetResult<ServicioPayload, S>

  type ServicioCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ServicioFindManyArgs, 'select' | 'include'> & {
      select?: ServicioCountAggregateInputType | true
    }

  export interface ServicioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Servicio'], meta: { name: 'Servicio' } }
    /**
     * Find zero or one Servicio that matches the filter.
     * @param {ServicioFindUniqueArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServicioFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServicioFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Servicio'> extends True ? Prisma__ServicioClient<$Types.GetResult<ServicioPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ServicioClient<$Types.GetResult<ServicioPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Servicio that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServicioFindUniqueOrThrowArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServicioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServicioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServicioClient<$Types.GetResult<ServicioPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Servicio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioFindFirstArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServicioFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServicioFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Servicio'> extends True ? Prisma__ServicioClient<$Types.GetResult<ServicioPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ServicioClient<$Types.GetResult<ServicioPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Servicio that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioFindFirstOrThrowArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServicioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServicioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServicioClient<$Types.GetResult<ServicioPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicios
     * const servicios = await prisma.servicio.findMany()
     * 
     * // Get first 10 Servicios
     * const servicios = await prisma.servicio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicioWithIdOnly = await prisma.servicio.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServicioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServicioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ServicioPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Servicio.
     * @param {ServicioCreateArgs} args - Arguments to create a Servicio.
     * @example
     * // Create one Servicio
     * const Servicio = await prisma.servicio.create({
     *   data: {
     *     // ... data to create a Servicio
     *   }
     * })
     * 
    **/
    create<T extends ServicioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ServicioCreateArgs<ExtArgs>>
    ): Prisma__ServicioClient<$Types.GetResult<ServicioPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Servicios.
     *     @param {ServicioCreateManyArgs} args - Arguments to create many Servicios.
     *     @example
     *     // Create many Servicios
     *     const servicio = await prisma.servicio.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServicioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServicioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicio.
     * @param {ServicioDeleteArgs} args - Arguments to delete one Servicio.
     * @example
     * // Delete one Servicio
     * const Servicio = await prisma.servicio.delete({
     *   where: {
     *     // ... filter to delete one Servicio
     *   }
     * })
     * 
    **/
    delete<T extends ServicioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ServicioDeleteArgs<ExtArgs>>
    ): Prisma__ServicioClient<$Types.GetResult<ServicioPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Servicio.
     * @param {ServicioUpdateArgs} args - Arguments to update one Servicio.
     * @example
     * // Update one Servicio
     * const servicio = await prisma.servicio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServicioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ServicioUpdateArgs<ExtArgs>>
    ): Prisma__ServicioClient<$Types.GetResult<ServicioPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Servicios.
     * @param {ServicioDeleteManyArgs} args - Arguments to filter Servicios to delete.
     * @example
     * // Delete a few Servicios
     * const { count } = await prisma.servicio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServicioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServicioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicios
     * const servicio = await prisma.servicio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServicioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ServicioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicio.
     * @param {ServicioUpsertArgs} args - Arguments to update or create a Servicio.
     * @example
     * // Update or create a Servicio
     * const servicio = await prisma.servicio.upsert({
     *   create: {
     *     // ... data to create a Servicio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicio we want to update
     *   }
     * })
    **/
    upsert<T extends ServicioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ServicioUpsertArgs<ExtArgs>>
    ): Prisma__ServicioClient<$Types.GetResult<ServicioPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Find zero or more Servicios that matches the filter.
     * @param {ServicioFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const servicio = await prisma.servicio.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ServicioFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Servicio.
     * @param {ServicioAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const servicio = await prisma.servicio.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ServicioAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioCountArgs} args - Arguments to filter Servicios to count.
     * @example
     * // Count the number of Servicios
     * const count = await prisma.servicio.count({
     *   where: {
     *     // ... the filter for the Servicios we want to count
     *   }
     * })
    **/
    count<T extends ServicioCountArgs>(
      args?: Subset<T, ServicioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicioAggregateArgs>(args: Subset<T, ServicioAggregateArgs>): Prisma.PrismaPromise<GetServicioAggregateType<T>>

    /**
     * Group by Servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicioGroupByArgs['orderBy'] }
        : { orderBy?: ServicioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Servicio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServicioClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    disponibilidades<T extends Servicio$disponibilidadesArgs<ExtArgs> = {}>(args?: Subset<T, Servicio$disponibilidadesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DisponibilidadPayload<ExtArgs>, T, 'findMany', never>| Null>;

    solicitudes<T extends Servicio$solicitudesArgs<ExtArgs> = {}>(args?: Subset<T, Servicio$solicitudesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<SolicitudPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Servicio base type for findUnique actions
   */
  export type ServicioFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicio to fetch.
     */
    where: ServicioWhereUniqueInput
  }

  /**
   * Servicio findUnique
   */
  export interface ServicioFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServicioFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Servicio findUniqueOrThrow
   */
  export type ServicioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicio to fetch.
     */
    where: ServicioWhereUniqueInput
  }


  /**
   * Servicio base type for findFirst actions
   */
  export type ServicioFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicio to fetch.
     */
    where?: ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: Enumerable<ServicioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servicios.
     */
    cursor?: ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servicios.
     */
    distinct?: Enumerable<ServicioScalarFieldEnum>
  }

  /**
   * Servicio findFirst
   */
  export interface ServicioFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServicioFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Servicio findFirstOrThrow
   */
  export type ServicioFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicio to fetch.
     */
    where?: ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: Enumerable<ServicioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servicios.
     */
    cursor?: ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servicios.
     */
    distinct?: Enumerable<ServicioScalarFieldEnum>
  }


  /**
   * Servicio findMany
   */
  export type ServicioFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicios to fetch.
     */
    where?: ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: Enumerable<ServicioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Servicios.
     */
    cursor?: ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    distinct?: Enumerable<ServicioScalarFieldEnum>
  }


  /**
   * Servicio create
   */
  export type ServicioCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * The data needed to create a Servicio.
     */
    data: XOR<ServicioCreateInput, ServicioUncheckedCreateInput>
  }


  /**
   * Servicio createMany
   */
  export type ServicioCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Servicios.
     */
    data: Enumerable<ServicioCreateManyInput>
  }


  /**
   * Servicio update
   */
  export type ServicioUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * The data needed to update a Servicio.
     */
    data: XOR<ServicioUpdateInput, ServicioUncheckedUpdateInput>
    /**
     * Choose, which Servicio to update.
     */
    where: ServicioWhereUniqueInput
  }


  /**
   * Servicio updateMany
   */
  export type ServicioUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Servicios.
     */
    data: XOR<ServicioUpdateManyMutationInput, ServicioUncheckedUpdateManyInput>
    /**
     * Filter which Servicios to update
     */
    where?: ServicioWhereInput
  }


  /**
   * Servicio upsert
   */
  export type ServicioUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * The filter to search for the Servicio to update in case it exists.
     */
    where: ServicioWhereUniqueInput
    /**
     * In case the Servicio found by the `where` argument doesn't exist, create a new Servicio with this data.
     */
    create: XOR<ServicioCreateInput, ServicioUncheckedCreateInput>
    /**
     * In case the Servicio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicioUpdateInput, ServicioUncheckedUpdateInput>
  }


  /**
   * Servicio delete
   */
  export type ServicioDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter which Servicio to delete.
     */
    where: ServicioWhereUniqueInput
  }


  /**
   * Servicio deleteMany
   */
  export type ServicioDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Servicios to delete
     */
    where?: ServicioWhereInput
  }


  /**
   * Servicio findRaw
   */
  export type ServicioFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Servicio aggregateRaw
   */
  export type ServicioAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Servicio.disponibilidades
   */
  export type Servicio$disponibilidadesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disponibilidad
     */
    select?: DisponibilidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DisponibilidadInclude<ExtArgs> | null
    where?: DisponibilidadWhereInput
    orderBy?: Enumerable<DisponibilidadOrderByWithRelationInput>
    cursor?: DisponibilidadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DisponibilidadScalarFieldEnum>
  }


  /**
   * Servicio.solicitudes
   */
  export type Servicio$solicitudesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solicitud
     */
    select?: SolicitudSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitudInclude<ExtArgs> | null
    where?: SolicitudWhereInput
    orderBy?: Enumerable<SolicitudOrderByWithRelationInput>
    cursor?: SolicitudWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SolicitudScalarFieldEnum>
  }


  /**
   * Servicio without action
   */
  export type ServicioArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServicioInclude<ExtArgs> | null
  }



  /**
   * Model Disponibilidad
   */


  export type AggregateDisponibilidad = {
    _count: DisponibilidadCountAggregateOutputType | null
    _min: DisponibilidadMinAggregateOutputType | null
    _max: DisponibilidadMaxAggregateOutputType | null
  }

  export type DisponibilidadMinAggregateOutputType = {
    id: string | null
    cuidador_id: string | null
    fecha_disponible: Date | null
    servicio_id: string | null
  }

  export type DisponibilidadMaxAggregateOutputType = {
    id: string | null
    cuidador_id: string | null
    fecha_disponible: Date | null
    servicio_id: string | null
  }

  export type DisponibilidadCountAggregateOutputType = {
    id: number
    cuidador_id: number
    fecha_disponible: number
    servicio_id: number
    _all: number
  }


  export type DisponibilidadMinAggregateInputType = {
    id?: true
    cuidador_id?: true
    fecha_disponible?: true
    servicio_id?: true
  }

  export type DisponibilidadMaxAggregateInputType = {
    id?: true
    cuidador_id?: true
    fecha_disponible?: true
    servicio_id?: true
  }

  export type DisponibilidadCountAggregateInputType = {
    id?: true
    cuidador_id?: true
    fecha_disponible?: true
    servicio_id?: true
    _all?: true
  }

  export type DisponibilidadAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Disponibilidad to aggregate.
     */
    where?: DisponibilidadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disponibilidads to fetch.
     */
    orderBy?: Enumerable<DisponibilidadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisponibilidadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disponibilidads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disponibilidads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Disponibilidads
    **/
    _count?: true | DisponibilidadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisponibilidadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisponibilidadMaxAggregateInputType
  }

  export type GetDisponibilidadAggregateType<T extends DisponibilidadAggregateArgs> = {
        [P in keyof T & keyof AggregateDisponibilidad]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisponibilidad[P]>
      : GetScalarType<T[P], AggregateDisponibilidad[P]>
  }




  export type DisponibilidadGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DisponibilidadWhereInput
    orderBy?: Enumerable<DisponibilidadOrderByWithAggregationInput>
    by: DisponibilidadScalarFieldEnum[]
    having?: DisponibilidadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisponibilidadCountAggregateInputType | true
    _min?: DisponibilidadMinAggregateInputType
    _max?: DisponibilidadMaxAggregateInputType
  }


  export type DisponibilidadGroupByOutputType = {
    id: string
    cuidador_id: string
    fecha_disponible: Date
    servicio_id: string
    _count: DisponibilidadCountAggregateOutputType | null
    _min: DisponibilidadMinAggregateOutputType | null
    _max: DisponibilidadMaxAggregateOutputType | null
  }

  type GetDisponibilidadGroupByPayload<T extends DisponibilidadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DisponibilidadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisponibilidadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisponibilidadGroupByOutputType[P]>
            : GetScalarType<T[P], DisponibilidadGroupByOutputType[P]>
        }
      >
    >


  export type DisponibilidadSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cuidador_id?: boolean
    fecha_disponible?: boolean
    servicio_id?: boolean
    cuidador?: boolean | CuidadorArgs<ExtArgs>
    servicio?: boolean | ServicioArgs<ExtArgs>
  }, ExtArgs["result"]["disponibilidad"]>

  export type DisponibilidadSelectScalar = {
    id?: boolean
    cuidador_id?: boolean
    fecha_disponible?: boolean
    servicio_id?: boolean
  }

  export type DisponibilidadInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    cuidador?: boolean | CuidadorArgs<ExtArgs>
    servicio?: boolean | ServicioArgs<ExtArgs>
  }


  type DisponibilidadGetPayload<S extends boolean | null | undefined | DisponibilidadArgs> = $Types.GetResult<DisponibilidadPayload, S>

  type DisponibilidadCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DisponibilidadFindManyArgs, 'select' | 'include'> & {
      select?: DisponibilidadCountAggregateInputType | true
    }

  export interface DisponibilidadDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Disponibilidad'], meta: { name: 'Disponibilidad' } }
    /**
     * Find zero or one Disponibilidad that matches the filter.
     * @param {DisponibilidadFindUniqueArgs} args - Arguments to find a Disponibilidad
     * @example
     * // Get one Disponibilidad
     * const disponibilidad = await prisma.disponibilidad.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DisponibilidadFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DisponibilidadFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Disponibilidad'> extends True ? Prisma__DisponibilidadClient<$Types.GetResult<DisponibilidadPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DisponibilidadClient<$Types.GetResult<DisponibilidadPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Disponibilidad that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DisponibilidadFindUniqueOrThrowArgs} args - Arguments to find a Disponibilidad
     * @example
     * // Get one Disponibilidad
     * const disponibilidad = await prisma.disponibilidad.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DisponibilidadFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DisponibilidadFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DisponibilidadClient<$Types.GetResult<DisponibilidadPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Disponibilidad that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibilidadFindFirstArgs} args - Arguments to find a Disponibilidad
     * @example
     * // Get one Disponibilidad
     * const disponibilidad = await prisma.disponibilidad.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DisponibilidadFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DisponibilidadFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Disponibilidad'> extends True ? Prisma__DisponibilidadClient<$Types.GetResult<DisponibilidadPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DisponibilidadClient<$Types.GetResult<DisponibilidadPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Disponibilidad that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibilidadFindFirstOrThrowArgs} args - Arguments to find a Disponibilidad
     * @example
     * // Get one Disponibilidad
     * const disponibilidad = await prisma.disponibilidad.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DisponibilidadFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DisponibilidadFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DisponibilidadClient<$Types.GetResult<DisponibilidadPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Disponibilidads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibilidadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Disponibilidads
     * const disponibilidads = await prisma.disponibilidad.findMany()
     * 
     * // Get first 10 Disponibilidads
     * const disponibilidads = await prisma.disponibilidad.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disponibilidadWithIdOnly = await prisma.disponibilidad.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DisponibilidadFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DisponibilidadFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DisponibilidadPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Disponibilidad.
     * @param {DisponibilidadCreateArgs} args - Arguments to create a Disponibilidad.
     * @example
     * // Create one Disponibilidad
     * const Disponibilidad = await prisma.disponibilidad.create({
     *   data: {
     *     // ... data to create a Disponibilidad
     *   }
     * })
     * 
    **/
    create<T extends DisponibilidadCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DisponibilidadCreateArgs<ExtArgs>>
    ): Prisma__DisponibilidadClient<$Types.GetResult<DisponibilidadPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Disponibilidads.
     *     @param {DisponibilidadCreateManyArgs} args - Arguments to create many Disponibilidads.
     *     @example
     *     // Create many Disponibilidads
     *     const disponibilidad = await prisma.disponibilidad.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DisponibilidadCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DisponibilidadCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Disponibilidad.
     * @param {DisponibilidadDeleteArgs} args - Arguments to delete one Disponibilidad.
     * @example
     * // Delete one Disponibilidad
     * const Disponibilidad = await prisma.disponibilidad.delete({
     *   where: {
     *     // ... filter to delete one Disponibilidad
     *   }
     * })
     * 
    **/
    delete<T extends DisponibilidadDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DisponibilidadDeleteArgs<ExtArgs>>
    ): Prisma__DisponibilidadClient<$Types.GetResult<DisponibilidadPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Disponibilidad.
     * @param {DisponibilidadUpdateArgs} args - Arguments to update one Disponibilidad.
     * @example
     * // Update one Disponibilidad
     * const disponibilidad = await prisma.disponibilidad.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DisponibilidadUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DisponibilidadUpdateArgs<ExtArgs>>
    ): Prisma__DisponibilidadClient<$Types.GetResult<DisponibilidadPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Disponibilidads.
     * @param {DisponibilidadDeleteManyArgs} args - Arguments to filter Disponibilidads to delete.
     * @example
     * // Delete a few Disponibilidads
     * const { count } = await prisma.disponibilidad.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DisponibilidadDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DisponibilidadDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Disponibilidads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibilidadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Disponibilidads
     * const disponibilidad = await prisma.disponibilidad.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DisponibilidadUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DisponibilidadUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Disponibilidad.
     * @param {DisponibilidadUpsertArgs} args - Arguments to update or create a Disponibilidad.
     * @example
     * // Update or create a Disponibilidad
     * const disponibilidad = await prisma.disponibilidad.upsert({
     *   create: {
     *     // ... data to create a Disponibilidad
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Disponibilidad we want to update
     *   }
     * })
    **/
    upsert<T extends DisponibilidadUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DisponibilidadUpsertArgs<ExtArgs>>
    ): Prisma__DisponibilidadClient<$Types.GetResult<DisponibilidadPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Find zero or more Disponibilidads that matches the filter.
     * @param {DisponibilidadFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const disponibilidad = await prisma.disponibilidad.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: DisponibilidadFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Disponibilidad.
     * @param {DisponibilidadAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const disponibilidad = await prisma.disponibilidad.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: DisponibilidadAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Disponibilidads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibilidadCountArgs} args - Arguments to filter Disponibilidads to count.
     * @example
     * // Count the number of Disponibilidads
     * const count = await prisma.disponibilidad.count({
     *   where: {
     *     // ... the filter for the Disponibilidads we want to count
     *   }
     * })
    **/
    count<T extends DisponibilidadCountArgs>(
      args?: Subset<T, DisponibilidadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisponibilidadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Disponibilidad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibilidadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisponibilidadAggregateArgs>(args: Subset<T, DisponibilidadAggregateArgs>): Prisma.PrismaPromise<GetDisponibilidadAggregateType<T>>

    /**
     * Group by Disponibilidad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibilidadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisponibilidadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisponibilidadGroupByArgs['orderBy'] }
        : { orderBy?: DisponibilidadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisponibilidadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisponibilidadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Disponibilidad.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DisponibilidadClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    cuidador<T extends CuidadorArgs<ExtArgs> = {}>(args?: Subset<T, CuidadorArgs<ExtArgs>>): Prisma__CuidadorClient<$Types.GetResult<CuidadorPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    servicio<T extends ServicioArgs<ExtArgs> = {}>(args?: Subset<T, ServicioArgs<ExtArgs>>): Prisma__ServicioClient<$Types.GetResult<ServicioPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Disponibilidad base type for findUnique actions
   */
  export type DisponibilidadFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disponibilidad
     */
    select?: DisponibilidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DisponibilidadInclude<ExtArgs> | null
    /**
     * Filter, which Disponibilidad to fetch.
     */
    where: DisponibilidadWhereUniqueInput
  }

  /**
   * Disponibilidad findUnique
   */
  export interface DisponibilidadFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DisponibilidadFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Disponibilidad findUniqueOrThrow
   */
  export type DisponibilidadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disponibilidad
     */
    select?: DisponibilidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DisponibilidadInclude<ExtArgs> | null
    /**
     * Filter, which Disponibilidad to fetch.
     */
    where: DisponibilidadWhereUniqueInput
  }


  /**
   * Disponibilidad base type for findFirst actions
   */
  export type DisponibilidadFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disponibilidad
     */
    select?: DisponibilidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DisponibilidadInclude<ExtArgs> | null
    /**
     * Filter, which Disponibilidad to fetch.
     */
    where?: DisponibilidadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disponibilidads to fetch.
     */
    orderBy?: Enumerable<DisponibilidadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Disponibilidads.
     */
    cursor?: DisponibilidadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disponibilidads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disponibilidads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Disponibilidads.
     */
    distinct?: Enumerable<DisponibilidadScalarFieldEnum>
  }

  /**
   * Disponibilidad findFirst
   */
  export interface DisponibilidadFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DisponibilidadFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Disponibilidad findFirstOrThrow
   */
  export type DisponibilidadFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disponibilidad
     */
    select?: DisponibilidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DisponibilidadInclude<ExtArgs> | null
    /**
     * Filter, which Disponibilidad to fetch.
     */
    where?: DisponibilidadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disponibilidads to fetch.
     */
    orderBy?: Enumerable<DisponibilidadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Disponibilidads.
     */
    cursor?: DisponibilidadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disponibilidads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disponibilidads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Disponibilidads.
     */
    distinct?: Enumerable<DisponibilidadScalarFieldEnum>
  }


  /**
   * Disponibilidad findMany
   */
  export type DisponibilidadFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disponibilidad
     */
    select?: DisponibilidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DisponibilidadInclude<ExtArgs> | null
    /**
     * Filter, which Disponibilidads to fetch.
     */
    where?: DisponibilidadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disponibilidads to fetch.
     */
    orderBy?: Enumerable<DisponibilidadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Disponibilidads.
     */
    cursor?: DisponibilidadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disponibilidads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disponibilidads.
     */
    skip?: number
    distinct?: Enumerable<DisponibilidadScalarFieldEnum>
  }


  /**
   * Disponibilidad create
   */
  export type DisponibilidadCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disponibilidad
     */
    select?: DisponibilidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DisponibilidadInclude<ExtArgs> | null
    /**
     * The data needed to create a Disponibilidad.
     */
    data: XOR<DisponibilidadCreateInput, DisponibilidadUncheckedCreateInput>
  }


  /**
   * Disponibilidad createMany
   */
  export type DisponibilidadCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Disponibilidads.
     */
    data: Enumerable<DisponibilidadCreateManyInput>
  }


  /**
   * Disponibilidad update
   */
  export type DisponibilidadUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disponibilidad
     */
    select?: DisponibilidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DisponibilidadInclude<ExtArgs> | null
    /**
     * The data needed to update a Disponibilidad.
     */
    data: XOR<DisponibilidadUpdateInput, DisponibilidadUncheckedUpdateInput>
    /**
     * Choose, which Disponibilidad to update.
     */
    where: DisponibilidadWhereUniqueInput
  }


  /**
   * Disponibilidad updateMany
   */
  export type DisponibilidadUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Disponibilidads.
     */
    data: XOR<DisponibilidadUpdateManyMutationInput, DisponibilidadUncheckedUpdateManyInput>
    /**
     * Filter which Disponibilidads to update
     */
    where?: DisponibilidadWhereInput
  }


  /**
   * Disponibilidad upsert
   */
  export type DisponibilidadUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disponibilidad
     */
    select?: DisponibilidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DisponibilidadInclude<ExtArgs> | null
    /**
     * The filter to search for the Disponibilidad to update in case it exists.
     */
    where: DisponibilidadWhereUniqueInput
    /**
     * In case the Disponibilidad found by the `where` argument doesn't exist, create a new Disponibilidad with this data.
     */
    create: XOR<DisponibilidadCreateInput, DisponibilidadUncheckedCreateInput>
    /**
     * In case the Disponibilidad was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisponibilidadUpdateInput, DisponibilidadUncheckedUpdateInput>
  }


  /**
   * Disponibilidad delete
   */
  export type DisponibilidadDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disponibilidad
     */
    select?: DisponibilidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DisponibilidadInclude<ExtArgs> | null
    /**
     * Filter which Disponibilidad to delete.
     */
    where: DisponibilidadWhereUniqueInput
  }


  /**
   * Disponibilidad deleteMany
   */
  export type DisponibilidadDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Disponibilidads to delete
     */
    where?: DisponibilidadWhereInput
  }


  /**
   * Disponibilidad findRaw
   */
  export type DisponibilidadFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Disponibilidad aggregateRaw
   */
  export type DisponibilidadAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Disponibilidad without action
   */
  export type DisponibilidadArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disponibilidad
     */
    select?: DisponibilidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DisponibilidadInclude<ExtArgs> | null
  }



  /**
   * Model Solicitud
   */


  export type AggregateSolicitud = {
    _count: SolicitudCountAggregateOutputType | null
    _min: SolicitudMinAggregateOutputType | null
    _max: SolicitudMaxAggregateOutputType | null
  }

  export type SolicitudMinAggregateOutputType = {
    id: string | null
    usuario_id: string | null
    cuidador_id: string | null
    servicio_id: string | null
    fecha_solicitada: Date | null
    estado: string | null
    fecha_respuesta: Date | null
  }

  export type SolicitudMaxAggregateOutputType = {
    id: string | null
    usuario_id: string | null
    cuidador_id: string | null
    servicio_id: string | null
    fecha_solicitada: Date | null
    estado: string | null
    fecha_respuesta: Date | null
  }

  export type SolicitudCountAggregateOutputType = {
    id: number
    usuario_id: number
    cuidador_id: number
    servicio_id: number
    fecha_solicitada: number
    estado: number
    fecha_respuesta: number
    _all: number
  }


  export type SolicitudMinAggregateInputType = {
    id?: true
    usuario_id?: true
    cuidador_id?: true
    servicio_id?: true
    fecha_solicitada?: true
    estado?: true
    fecha_respuesta?: true
  }

  export type SolicitudMaxAggregateInputType = {
    id?: true
    usuario_id?: true
    cuidador_id?: true
    servicio_id?: true
    fecha_solicitada?: true
    estado?: true
    fecha_respuesta?: true
  }

  export type SolicitudCountAggregateInputType = {
    id?: true
    usuario_id?: true
    cuidador_id?: true
    servicio_id?: true
    fecha_solicitada?: true
    estado?: true
    fecha_respuesta?: true
    _all?: true
  }

  export type SolicitudAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Solicitud to aggregate.
     */
    where?: SolicitudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Solicituds to fetch.
     */
    orderBy?: Enumerable<SolicitudOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SolicitudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Solicituds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Solicituds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Solicituds
    **/
    _count?: true | SolicitudCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SolicitudMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SolicitudMaxAggregateInputType
  }

  export type GetSolicitudAggregateType<T extends SolicitudAggregateArgs> = {
        [P in keyof T & keyof AggregateSolicitud]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSolicitud[P]>
      : GetScalarType<T[P], AggregateSolicitud[P]>
  }




  export type SolicitudGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SolicitudWhereInput
    orderBy?: Enumerable<SolicitudOrderByWithAggregationInput>
    by: SolicitudScalarFieldEnum[]
    having?: SolicitudScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SolicitudCountAggregateInputType | true
    _min?: SolicitudMinAggregateInputType
    _max?: SolicitudMaxAggregateInputType
  }


  export type SolicitudGroupByOutputType = {
    id: string
    usuario_id: string
    cuidador_id: string
    servicio_id: string
    fecha_solicitada: Date
    estado: string
    fecha_respuesta: Date | null
    _count: SolicitudCountAggregateOutputType | null
    _min: SolicitudMinAggregateOutputType | null
    _max: SolicitudMaxAggregateOutputType | null
  }

  type GetSolicitudGroupByPayload<T extends SolicitudGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SolicitudGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SolicitudGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SolicitudGroupByOutputType[P]>
            : GetScalarType<T[P], SolicitudGroupByOutputType[P]>
        }
      >
    >


  export type SolicitudSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    cuidador_id?: boolean
    servicio_id?: boolean
    fecha_solicitada?: boolean
    estado?: boolean
    fecha_respuesta?: boolean
    usuario?: boolean | UsuarioArgs<ExtArgs>
    cuidador?: boolean | CuidadorArgs<ExtArgs>
    servicio?: boolean | ServicioArgs<ExtArgs>
    comentario?: boolean | ComentarioArgs<ExtArgs>
    mensajes?: boolean | Solicitud$mensajesArgs<ExtArgs>
    _count?: boolean | SolicitudCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["solicitud"]>

  export type SolicitudSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    cuidador_id?: boolean
    servicio_id?: boolean
    fecha_solicitada?: boolean
    estado?: boolean
    fecha_respuesta?: boolean
  }

  export type SolicitudInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioArgs<ExtArgs>
    cuidador?: boolean | CuidadorArgs<ExtArgs>
    servicio?: boolean | ServicioArgs<ExtArgs>
    comentario?: boolean | ComentarioArgs<ExtArgs>
    mensajes?: boolean | Solicitud$mensajesArgs<ExtArgs>
    _count?: boolean | SolicitudCountOutputTypeArgs<ExtArgs>
  }


  type SolicitudGetPayload<S extends boolean | null | undefined | SolicitudArgs> = $Types.GetResult<SolicitudPayload, S>

  type SolicitudCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SolicitudFindManyArgs, 'select' | 'include'> & {
      select?: SolicitudCountAggregateInputType | true
    }

  export interface SolicitudDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Solicitud'], meta: { name: 'Solicitud' } }
    /**
     * Find zero or one Solicitud that matches the filter.
     * @param {SolicitudFindUniqueArgs} args - Arguments to find a Solicitud
     * @example
     * // Get one Solicitud
     * const solicitud = await prisma.solicitud.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SolicitudFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SolicitudFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Solicitud'> extends True ? Prisma__SolicitudClient<$Types.GetResult<SolicitudPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__SolicitudClient<$Types.GetResult<SolicitudPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Solicitud that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SolicitudFindUniqueOrThrowArgs} args - Arguments to find a Solicitud
     * @example
     * // Get one Solicitud
     * const solicitud = await prisma.solicitud.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SolicitudFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SolicitudFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SolicitudClient<$Types.GetResult<SolicitudPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Solicitud that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolicitudFindFirstArgs} args - Arguments to find a Solicitud
     * @example
     * // Get one Solicitud
     * const solicitud = await prisma.solicitud.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SolicitudFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SolicitudFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Solicitud'> extends True ? Prisma__SolicitudClient<$Types.GetResult<SolicitudPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__SolicitudClient<$Types.GetResult<SolicitudPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Solicitud that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolicitudFindFirstOrThrowArgs} args - Arguments to find a Solicitud
     * @example
     * // Get one Solicitud
     * const solicitud = await prisma.solicitud.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SolicitudFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SolicitudFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SolicitudClient<$Types.GetResult<SolicitudPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Solicituds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolicitudFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Solicituds
     * const solicituds = await prisma.solicitud.findMany()
     * 
     * // Get first 10 Solicituds
     * const solicituds = await prisma.solicitud.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const solicitudWithIdOnly = await prisma.solicitud.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SolicitudFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SolicitudFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<SolicitudPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Solicitud.
     * @param {SolicitudCreateArgs} args - Arguments to create a Solicitud.
     * @example
     * // Create one Solicitud
     * const Solicitud = await prisma.solicitud.create({
     *   data: {
     *     // ... data to create a Solicitud
     *   }
     * })
     * 
    **/
    create<T extends SolicitudCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SolicitudCreateArgs<ExtArgs>>
    ): Prisma__SolicitudClient<$Types.GetResult<SolicitudPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Solicituds.
     *     @param {SolicitudCreateManyArgs} args - Arguments to create many Solicituds.
     *     @example
     *     // Create many Solicituds
     *     const solicitud = await prisma.solicitud.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SolicitudCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SolicitudCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Solicitud.
     * @param {SolicitudDeleteArgs} args - Arguments to delete one Solicitud.
     * @example
     * // Delete one Solicitud
     * const Solicitud = await prisma.solicitud.delete({
     *   where: {
     *     // ... filter to delete one Solicitud
     *   }
     * })
     * 
    **/
    delete<T extends SolicitudDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SolicitudDeleteArgs<ExtArgs>>
    ): Prisma__SolicitudClient<$Types.GetResult<SolicitudPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Solicitud.
     * @param {SolicitudUpdateArgs} args - Arguments to update one Solicitud.
     * @example
     * // Update one Solicitud
     * const solicitud = await prisma.solicitud.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SolicitudUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SolicitudUpdateArgs<ExtArgs>>
    ): Prisma__SolicitudClient<$Types.GetResult<SolicitudPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Solicituds.
     * @param {SolicitudDeleteManyArgs} args - Arguments to filter Solicituds to delete.
     * @example
     * // Delete a few Solicituds
     * const { count } = await prisma.solicitud.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SolicitudDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SolicitudDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Solicituds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolicitudUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Solicituds
     * const solicitud = await prisma.solicitud.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SolicitudUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SolicitudUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Solicitud.
     * @param {SolicitudUpsertArgs} args - Arguments to update or create a Solicitud.
     * @example
     * // Update or create a Solicitud
     * const solicitud = await prisma.solicitud.upsert({
     *   create: {
     *     // ... data to create a Solicitud
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Solicitud we want to update
     *   }
     * })
    **/
    upsert<T extends SolicitudUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SolicitudUpsertArgs<ExtArgs>>
    ): Prisma__SolicitudClient<$Types.GetResult<SolicitudPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Find zero or more Solicituds that matches the filter.
     * @param {SolicitudFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const solicitud = await prisma.solicitud.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: SolicitudFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Solicitud.
     * @param {SolicitudAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const solicitud = await prisma.solicitud.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: SolicitudAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Solicituds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolicitudCountArgs} args - Arguments to filter Solicituds to count.
     * @example
     * // Count the number of Solicituds
     * const count = await prisma.solicitud.count({
     *   where: {
     *     // ... the filter for the Solicituds we want to count
     *   }
     * })
    **/
    count<T extends SolicitudCountArgs>(
      args?: Subset<T, SolicitudCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SolicitudCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Solicitud.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolicitudAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SolicitudAggregateArgs>(args: Subset<T, SolicitudAggregateArgs>): Prisma.PrismaPromise<GetSolicitudAggregateType<T>>

    /**
     * Group by Solicitud.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolicitudGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SolicitudGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SolicitudGroupByArgs['orderBy'] }
        : { orderBy?: SolicitudGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SolicitudGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSolicitudGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Solicitud.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SolicitudClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    usuario<T extends UsuarioArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioArgs<ExtArgs>>): Prisma__UsuarioClient<$Types.GetResult<UsuarioPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    cuidador<T extends CuidadorArgs<ExtArgs> = {}>(args?: Subset<T, CuidadorArgs<ExtArgs>>): Prisma__CuidadorClient<$Types.GetResult<CuidadorPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    servicio<T extends ServicioArgs<ExtArgs> = {}>(args?: Subset<T, ServicioArgs<ExtArgs>>): Prisma__ServicioClient<$Types.GetResult<ServicioPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    comentario<T extends ComentarioArgs<ExtArgs> = {}>(args?: Subset<T, ComentarioArgs<ExtArgs>>): Prisma__ComentarioClient<$Types.GetResult<ComentarioPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    mensajes<T extends Solicitud$mensajesArgs<ExtArgs> = {}>(args?: Subset<T, Solicitud$mensajesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<MensajePayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Solicitud base type for findUnique actions
   */
  export type SolicitudFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solicitud
     */
    select?: SolicitudSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitudInclude<ExtArgs> | null
    /**
     * Filter, which Solicitud to fetch.
     */
    where: SolicitudWhereUniqueInput
  }

  /**
   * Solicitud findUnique
   */
  export interface SolicitudFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SolicitudFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Solicitud findUniqueOrThrow
   */
  export type SolicitudFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solicitud
     */
    select?: SolicitudSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitudInclude<ExtArgs> | null
    /**
     * Filter, which Solicitud to fetch.
     */
    where: SolicitudWhereUniqueInput
  }


  /**
   * Solicitud base type for findFirst actions
   */
  export type SolicitudFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solicitud
     */
    select?: SolicitudSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitudInclude<ExtArgs> | null
    /**
     * Filter, which Solicitud to fetch.
     */
    where?: SolicitudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Solicituds to fetch.
     */
    orderBy?: Enumerable<SolicitudOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Solicituds.
     */
    cursor?: SolicitudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Solicituds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Solicituds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Solicituds.
     */
    distinct?: Enumerable<SolicitudScalarFieldEnum>
  }

  /**
   * Solicitud findFirst
   */
  export interface SolicitudFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SolicitudFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Solicitud findFirstOrThrow
   */
  export type SolicitudFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solicitud
     */
    select?: SolicitudSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitudInclude<ExtArgs> | null
    /**
     * Filter, which Solicitud to fetch.
     */
    where?: SolicitudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Solicituds to fetch.
     */
    orderBy?: Enumerable<SolicitudOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Solicituds.
     */
    cursor?: SolicitudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Solicituds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Solicituds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Solicituds.
     */
    distinct?: Enumerable<SolicitudScalarFieldEnum>
  }


  /**
   * Solicitud findMany
   */
  export type SolicitudFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solicitud
     */
    select?: SolicitudSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitudInclude<ExtArgs> | null
    /**
     * Filter, which Solicituds to fetch.
     */
    where?: SolicitudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Solicituds to fetch.
     */
    orderBy?: Enumerable<SolicitudOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Solicituds.
     */
    cursor?: SolicitudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Solicituds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Solicituds.
     */
    skip?: number
    distinct?: Enumerable<SolicitudScalarFieldEnum>
  }


  /**
   * Solicitud create
   */
  export type SolicitudCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solicitud
     */
    select?: SolicitudSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitudInclude<ExtArgs> | null
    /**
     * The data needed to create a Solicitud.
     */
    data: XOR<SolicitudCreateInput, SolicitudUncheckedCreateInput>
  }


  /**
   * Solicitud createMany
   */
  export type SolicitudCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Solicituds.
     */
    data: Enumerable<SolicitudCreateManyInput>
  }


  /**
   * Solicitud update
   */
  export type SolicitudUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solicitud
     */
    select?: SolicitudSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitudInclude<ExtArgs> | null
    /**
     * The data needed to update a Solicitud.
     */
    data: XOR<SolicitudUpdateInput, SolicitudUncheckedUpdateInput>
    /**
     * Choose, which Solicitud to update.
     */
    where: SolicitudWhereUniqueInput
  }


  /**
   * Solicitud updateMany
   */
  export type SolicitudUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Solicituds.
     */
    data: XOR<SolicitudUpdateManyMutationInput, SolicitudUncheckedUpdateManyInput>
    /**
     * Filter which Solicituds to update
     */
    where?: SolicitudWhereInput
  }


  /**
   * Solicitud upsert
   */
  export type SolicitudUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solicitud
     */
    select?: SolicitudSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitudInclude<ExtArgs> | null
    /**
     * The filter to search for the Solicitud to update in case it exists.
     */
    where: SolicitudWhereUniqueInput
    /**
     * In case the Solicitud found by the `where` argument doesn't exist, create a new Solicitud with this data.
     */
    create: XOR<SolicitudCreateInput, SolicitudUncheckedCreateInput>
    /**
     * In case the Solicitud was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SolicitudUpdateInput, SolicitudUncheckedUpdateInput>
  }


  /**
   * Solicitud delete
   */
  export type SolicitudDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solicitud
     */
    select?: SolicitudSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitudInclude<ExtArgs> | null
    /**
     * Filter which Solicitud to delete.
     */
    where: SolicitudWhereUniqueInput
  }


  /**
   * Solicitud deleteMany
   */
  export type SolicitudDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Solicituds to delete
     */
    where?: SolicitudWhereInput
  }


  /**
   * Solicitud findRaw
   */
  export type SolicitudFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Solicitud aggregateRaw
   */
  export type SolicitudAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Solicitud.mensajes
   */
  export type Solicitud$mensajesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensajeInclude<ExtArgs> | null
    where?: MensajeWhereInput
    orderBy?: Enumerable<MensajeOrderByWithRelationInput>
    cursor?: MensajeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MensajeScalarFieldEnum>
  }


  /**
   * Solicitud without action
   */
  export type SolicitudArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solicitud
     */
    select?: SolicitudSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitudInclude<ExtArgs> | null
  }



  /**
   * Model Comentario
   */


  export type AggregateComentario = {
    _count: ComentarioCountAggregateOutputType | null
    _avg: ComentarioAvgAggregateOutputType | null
    _sum: ComentarioSumAggregateOutputType | null
    _min: ComentarioMinAggregateOutputType | null
    _max: ComentarioMaxAggregateOutputType | null
  }

  export type ComentarioAvgAggregateOutputType = {
    calificacion: number | null
  }

  export type ComentarioSumAggregateOutputType = {
    calificacion: number | null
  }

  export type ComentarioMinAggregateOutputType = {
    id: string | null
    solicitud_id: string | null
    usuario_id: string | null
    calificacion: number | null
    comentario: string | null
    fecha: Date | null
  }

  export type ComentarioMaxAggregateOutputType = {
    id: string | null
    solicitud_id: string | null
    usuario_id: string | null
    calificacion: number | null
    comentario: string | null
    fecha: Date | null
  }

  export type ComentarioCountAggregateOutputType = {
    id: number
    solicitud_id: number
    usuario_id: number
    calificacion: number
    comentario: number
    fecha: number
    _all: number
  }


  export type ComentarioAvgAggregateInputType = {
    calificacion?: true
  }

  export type ComentarioSumAggregateInputType = {
    calificacion?: true
  }

  export type ComentarioMinAggregateInputType = {
    id?: true
    solicitud_id?: true
    usuario_id?: true
    calificacion?: true
    comentario?: true
    fecha?: true
  }

  export type ComentarioMaxAggregateInputType = {
    id?: true
    solicitud_id?: true
    usuario_id?: true
    calificacion?: true
    comentario?: true
    fecha?: true
  }

  export type ComentarioCountAggregateInputType = {
    id?: true
    solicitud_id?: true
    usuario_id?: true
    calificacion?: true
    comentario?: true
    fecha?: true
    _all?: true
  }

  export type ComentarioAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comentario to aggregate.
     */
    where?: ComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: Enumerable<ComentarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comentarios
    **/
    _count?: true | ComentarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComentarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComentarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComentarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComentarioMaxAggregateInputType
  }

  export type GetComentarioAggregateType<T extends ComentarioAggregateArgs> = {
        [P in keyof T & keyof AggregateComentario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComentario[P]>
      : GetScalarType<T[P], AggregateComentario[P]>
  }




  export type ComentarioGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ComentarioWhereInput
    orderBy?: Enumerable<ComentarioOrderByWithAggregationInput>
    by: ComentarioScalarFieldEnum[]
    having?: ComentarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComentarioCountAggregateInputType | true
    _avg?: ComentarioAvgAggregateInputType
    _sum?: ComentarioSumAggregateInputType
    _min?: ComentarioMinAggregateInputType
    _max?: ComentarioMaxAggregateInputType
  }


  export type ComentarioGroupByOutputType = {
    id: string
    solicitud_id: string
    usuario_id: string
    calificacion: number
    comentario: string | null
    fecha: Date
    _count: ComentarioCountAggregateOutputType | null
    _avg: ComentarioAvgAggregateOutputType | null
    _sum: ComentarioSumAggregateOutputType | null
    _min: ComentarioMinAggregateOutputType | null
    _max: ComentarioMaxAggregateOutputType | null
  }

  type GetComentarioGroupByPayload<T extends ComentarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ComentarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComentarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComentarioGroupByOutputType[P]>
            : GetScalarType<T[P], ComentarioGroupByOutputType[P]>
        }
      >
    >


  export type ComentarioSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    solicitud_id?: boolean
    usuario_id?: boolean
    calificacion?: boolean
    comentario?: boolean
    fecha?: boolean
    solicitud?: boolean | SolicitudArgs<ExtArgs>
    usuario?: boolean | UsuarioArgs<ExtArgs>
  }, ExtArgs["result"]["comentario"]>

  export type ComentarioSelectScalar = {
    id?: boolean
    solicitud_id?: boolean
    usuario_id?: boolean
    calificacion?: boolean
    comentario?: boolean
    fecha?: boolean
  }

  export type ComentarioInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    solicitud?: boolean | SolicitudArgs<ExtArgs>
    usuario?: boolean | UsuarioArgs<ExtArgs>
  }


  type ComentarioGetPayload<S extends boolean | null | undefined | ComentarioArgs> = $Types.GetResult<ComentarioPayload, S>

  type ComentarioCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ComentarioFindManyArgs, 'select' | 'include'> & {
      select?: ComentarioCountAggregateInputType | true
    }

  export interface ComentarioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comentario'], meta: { name: 'Comentario' } }
    /**
     * Find zero or one Comentario that matches the filter.
     * @param {ComentarioFindUniqueArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ComentarioFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ComentarioFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Comentario'> extends True ? Prisma__ComentarioClient<$Types.GetResult<ComentarioPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ComentarioClient<$Types.GetResult<ComentarioPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Comentario that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ComentarioFindUniqueOrThrowArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ComentarioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ComentarioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ComentarioClient<$Types.GetResult<ComentarioPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Comentario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioFindFirstArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ComentarioFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ComentarioFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Comentario'> extends True ? Prisma__ComentarioClient<$Types.GetResult<ComentarioPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ComentarioClient<$Types.GetResult<ComentarioPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Comentario that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioFindFirstOrThrowArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ComentarioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ComentarioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ComentarioClient<$Types.GetResult<ComentarioPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Comentarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comentarios
     * const comentarios = await prisma.comentario.findMany()
     * 
     * // Get first 10 Comentarios
     * const comentarios = await prisma.comentario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comentarioWithIdOnly = await prisma.comentario.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ComentarioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ComentarioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ComentarioPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Comentario.
     * @param {ComentarioCreateArgs} args - Arguments to create a Comentario.
     * @example
     * // Create one Comentario
     * const Comentario = await prisma.comentario.create({
     *   data: {
     *     // ... data to create a Comentario
     *   }
     * })
     * 
    **/
    create<T extends ComentarioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ComentarioCreateArgs<ExtArgs>>
    ): Prisma__ComentarioClient<$Types.GetResult<ComentarioPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Comentarios.
     *     @param {ComentarioCreateManyArgs} args - Arguments to create many Comentarios.
     *     @example
     *     // Create many Comentarios
     *     const comentario = await prisma.comentario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ComentarioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ComentarioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comentario.
     * @param {ComentarioDeleteArgs} args - Arguments to delete one Comentario.
     * @example
     * // Delete one Comentario
     * const Comentario = await prisma.comentario.delete({
     *   where: {
     *     // ... filter to delete one Comentario
     *   }
     * })
     * 
    **/
    delete<T extends ComentarioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ComentarioDeleteArgs<ExtArgs>>
    ): Prisma__ComentarioClient<$Types.GetResult<ComentarioPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Comentario.
     * @param {ComentarioUpdateArgs} args - Arguments to update one Comentario.
     * @example
     * // Update one Comentario
     * const comentario = await prisma.comentario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ComentarioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ComentarioUpdateArgs<ExtArgs>>
    ): Prisma__ComentarioClient<$Types.GetResult<ComentarioPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Comentarios.
     * @param {ComentarioDeleteManyArgs} args - Arguments to filter Comentarios to delete.
     * @example
     * // Delete a few Comentarios
     * const { count } = await prisma.comentario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ComentarioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ComentarioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comentarios
     * const comentario = await prisma.comentario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ComentarioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ComentarioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comentario.
     * @param {ComentarioUpsertArgs} args - Arguments to update or create a Comentario.
     * @example
     * // Update or create a Comentario
     * const comentario = await prisma.comentario.upsert({
     *   create: {
     *     // ... data to create a Comentario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comentario we want to update
     *   }
     * })
    **/
    upsert<T extends ComentarioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ComentarioUpsertArgs<ExtArgs>>
    ): Prisma__ComentarioClient<$Types.GetResult<ComentarioPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Find zero or more Comentarios that matches the filter.
     * @param {ComentarioFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const comentario = await prisma.comentario.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ComentarioFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Comentario.
     * @param {ComentarioAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const comentario = await prisma.comentario.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ComentarioAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioCountArgs} args - Arguments to filter Comentarios to count.
     * @example
     * // Count the number of Comentarios
     * const count = await prisma.comentario.count({
     *   where: {
     *     // ... the filter for the Comentarios we want to count
     *   }
     * })
    **/
    count<T extends ComentarioCountArgs>(
      args?: Subset<T, ComentarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComentarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comentario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComentarioAggregateArgs>(args: Subset<T, ComentarioAggregateArgs>): Prisma.PrismaPromise<GetComentarioAggregateType<T>>

    /**
     * Group by Comentario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComentarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComentarioGroupByArgs['orderBy'] }
        : { orderBy?: ComentarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComentarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComentarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Comentario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ComentarioClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    solicitud<T extends SolicitudArgs<ExtArgs> = {}>(args?: Subset<T, SolicitudArgs<ExtArgs>>): Prisma__SolicitudClient<$Types.GetResult<SolicitudPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    usuario<T extends UsuarioArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioArgs<ExtArgs>>): Prisma__UsuarioClient<$Types.GetResult<UsuarioPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Comentario base type for findUnique actions
   */
  export type ComentarioFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentario to fetch.
     */
    where: ComentarioWhereUniqueInput
  }

  /**
   * Comentario findUnique
   */
  export interface ComentarioFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ComentarioFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Comentario findUniqueOrThrow
   */
  export type ComentarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentario to fetch.
     */
    where: ComentarioWhereUniqueInput
  }


  /**
   * Comentario base type for findFirst actions
   */
  export type ComentarioFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentario to fetch.
     */
    where?: ComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: Enumerable<ComentarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comentarios.
     */
    cursor?: ComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comentarios.
     */
    distinct?: Enumerable<ComentarioScalarFieldEnum>
  }

  /**
   * Comentario findFirst
   */
  export interface ComentarioFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ComentarioFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Comentario findFirstOrThrow
   */
  export type ComentarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentario to fetch.
     */
    where?: ComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: Enumerable<ComentarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comentarios.
     */
    cursor?: ComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comentarios.
     */
    distinct?: Enumerable<ComentarioScalarFieldEnum>
  }


  /**
   * Comentario findMany
   */
  export type ComentarioFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentarios to fetch.
     */
    where?: ComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: Enumerable<ComentarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comentarios.
     */
    cursor?: ComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    distinct?: Enumerable<ComentarioScalarFieldEnum>
  }


  /**
   * Comentario create
   */
  export type ComentarioCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Comentario.
     */
    data: XOR<ComentarioCreateInput, ComentarioUncheckedCreateInput>
  }


  /**
   * Comentario createMany
   */
  export type ComentarioCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comentarios.
     */
    data: Enumerable<ComentarioCreateManyInput>
  }


  /**
   * Comentario update
   */
  export type ComentarioUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Comentario.
     */
    data: XOR<ComentarioUpdateInput, ComentarioUncheckedUpdateInput>
    /**
     * Choose, which Comentario to update.
     */
    where: ComentarioWhereUniqueInput
  }


  /**
   * Comentario updateMany
   */
  export type ComentarioUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comentarios.
     */
    data: XOR<ComentarioUpdateManyMutationInput, ComentarioUncheckedUpdateManyInput>
    /**
     * Filter which Comentarios to update
     */
    where?: ComentarioWhereInput
  }


  /**
   * Comentario upsert
   */
  export type ComentarioUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Comentario to update in case it exists.
     */
    where: ComentarioWhereUniqueInput
    /**
     * In case the Comentario found by the `where` argument doesn't exist, create a new Comentario with this data.
     */
    create: XOR<ComentarioCreateInput, ComentarioUncheckedCreateInput>
    /**
     * In case the Comentario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComentarioUpdateInput, ComentarioUncheckedUpdateInput>
  }


  /**
   * Comentario delete
   */
  export type ComentarioDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter which Comentario to delete.
     */
    where: ComentarioWhereUniqueInput
  }


  /**
   * Comentario deleteMany
   */
  export type ComentarioDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comentarios to delete
     */
    where?: ComentarioWhereInput
  }


  /**
   * Comentario findRaw
   */
  export type ComentarioFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Comentario aggregateRaw
   */
  export type ComentarioAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Comentario without action
   */
  export type ComentarioArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComentarioInclude<ExtArgs> | null
  }



  /**
   * Model Autenticacion
   */


  export type AggregateAutenticacion = {
    _count: AutenticacionCountAggregateOutputType | null
    _min: AutenticacionMinAggregateOutputType | null
    _max: AutenticacionMaxAggregateOutputType | null
  }

  export type AutenticacionMinAggregateOutputType = {
    id: string | null
    usuario_id: string | null
    token: string | null
    expiracion: Date | null
    tipo: string | null
  }

  export type AutenticacionMaxAggregateOutputType = {
    id: string | null
    usuario_id: string | null
    token: string | null
    expiracion: Date | null
    tipo: string | null
  }

  export type AutenticacionCountAggregateOutputType = {
    id: number
    usuario_id: number
    token: number
    expiracion: number
    tipo: number
    _all: number
  }


  export type AutenticacionMinAggregateInputType = {
    id?: true
    usuario_id?: true
    token?: true
    expiracion?: true
    tipo?: true
  }

  export type AutenticacionMaxAggregateInputType = {
    id?: true
    usuario_id?: true
    token?: true
    expiracion?: true
    tipo?: true
  }

  export type AutenticacionCountAggregateInputType = {
    id?: true
    usuario_id?: true
    token?: true
    expiracion?: true
    tipo?: true
    _all?: true
  }

  export type AutenticacionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Autenticacion to aggregate.
     */
    where?: AutenticacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Autenticacions to fetch.
     */
    orderBy?: Enumerable<AutenticacionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutenticacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Autenticacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Autenticacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Autenticacions
    **/
    _count?: true | AutenticacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutenticacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutenticacionMaxAggregateInputType
  }

  export type GetAutenticacionAggregateType<T extends AutenticacionAggregateArgs> = {
        [P in keyof T & keyof AggregateAutenticacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutenticacion[P]>
      : GetScalarType<T[P], AggregateAutenticacion[P]>
  }




  export type AutenticacionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AutenticacionWhereInput
    orderBy?: Enumerable<AutenticacionOrderByWithAggregationInput>
    by: AutenticacionScalarFieldEnum[]
    having?: AutenticacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutenticacionCountAggregateInputType | true
    _min?: AutenticacionMinAggregateInputType
    _max?: AutenticacionMaxAggregateInputType
  }


  export type AutenticacionGroupByOutputType = {
    id: string
    usuario_id: string
    token: string
    expiracion: Date
    tipo: string
    _count: AutenticacionCountAggregateOutputType | null
    _min: AutenticacionMinAggregateOutputType | null
    _max: AutenticacionMaxAggregateOutputType | null
  }

  type GetAutenticacionGroupByPayload<T extends AutenticacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AutenticacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutenticacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutenticacionGroupByOutputType[P]>
            : GetScalarType<T[P], AutenticacionGroupByOutputType[P]>
        }
      >
    >


  export type AutenticacionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    token?: boolean
    expiracion?: boolean
    tipo?: boolean
    usuario?: boolean | UsuarioArgs<ExtArgs>
  }, ExtArgs["result"]["autenticacion"]>

  export type AutenticacionSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    token?: boolean
    expiracion?: boolean
    tipo?: boolean
  }

  export type AutenticacionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioArgs<ExtArgs>
  }


  type AutenticacionGetPayload<S extends boolean | null | undefined | AutenticacionArgs> = $Types.GetResult<AutenticacionPayload, S>

  type AutenticacionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AutenticacionFindManyArgs, 'select' | 'include'> & {
      select?: AutenticacionCountAggregateInputType | true
    }

  export interface AutenticacionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Autenticacion'], meta: { name: 'Autenticacion' } }
    /**
     * Find zero or one Autenticacion that matches the filter.
     * @param {AutenticacionFindUniqueArgs} args - Arguments to find a Autenticacion
     * @example
     * // Get one Autenticacion
     * const autenticacion = await prisma.autenticacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AutenticacionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AutenticacionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Autenticacion'> extends True ? Prisma__AutenticacionClient<$Types.GetResult<AutenticacionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AutenticacionClient<$Types.GetResult<AutenticacionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Autenticacion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AutenticacionFindUniqueOrThrowArgs} args - Arguments to find a Autenticacion
     * @example
     * // Get one Autenticacion
     * const autenticacion = await prisma.autenticacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AutenticacionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AutenticacionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AutenticacionClient<$Types.GetResult<AutenticacionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Autenticacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutenticacionFindFirstArgs} args - Arguments to find a Autenticacion
     * @example
     * // Get one Autenticacion
     * const autenticacion = await prisma.autenticacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AutenticacionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AutenticacionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Autenticacion'> extends True ? Prisma__AutenticacionClient<$Types.GetResult<AutenticacionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AutenticacionClient<$Types.GetResult<AutenticacionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Autenticacion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutenticacionFindFirstOrThrowArgs} args - Arguments to find a Autenticacion
     * @example
     * // Get one Autenticacion
     * const autenticacion = await prisma.autenticacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AutenticacionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AutenticacionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AutenticacionClient<$Types.GetResult<AutenticacionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Autenticacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutenticacionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Autenticacions
     * const autenticacions = await prisma.autenticacion.findMany()
     * 
     * // Get first 10 Autenticacions
     * const autenticacions = await prisma.autenticacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const autenticacionWithIdOnly = await prisma.autenticacion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AutenticacionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AutenticacionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AutenticacionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Autenticacion.
     * @param {AutenticacionCreateArgs} args - Arguments to create a Autenticacion.
     * @example
     * // Create one Autenticacion
     * const Autenticacion = await prisma.autenticacion.create({
     *   data: {
     *     // ... data to create a Autenticacion
     *   }
     * })
     * 
    **/
    create<T extends AutenticacionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AutenticacionCreateArgs<ExtArgs>>
    ): Prisma__AutenticacionClient<$Types.GetResult<AutenticacionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Autenticacions.
     *     @param {AutenticacionCreateManyArgs} args - Arguments to create many Autenticacions.
     *     @example
     *     // Create many Autenticacions
     *     const autenticacion = await prisma.autenticacion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AutenticacionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AutenticacionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Autenticacion.
     * @param {AutenticacionDeleteArgs} args - Arguments to delete one Autenticacion.
     * @example
     * // Delete one Autenticacion
     * const Autenticacion = await prisma.autenticacion.delete({
     *   where: {
     *     // ... filter to delete one Autenticacion
     *   }
     * })
     * 
    **/
    delete<T extends AutenticacionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AutenticacionDeleteArgs<ExtArgs>>
    ): Prisma__AutenticacionClient<$Types.GetResult<AutenticacionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Autenticacion.
     * @param {AutenticacionUpdateArgs} args - Arguments to update one Autenticacion.
     * @example
     * // Update one Autenticacion
     * const autenticacion = await prisma.autenticacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AutenticacionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AutenticacionUpdateArgs<ExtArgs>>
    ): Prisma__AutenticacionClient<$Types.GetResult<AutenticacionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Autenticacions.
     * @param {AutenticacionDeleteManyArgs} args - Arguments to filter Autenticacions to delete.
     * @example
     * // Delete a few Autenticacions
     * const { count } = await prisma.autenticacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AutenticacionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AutenticacionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Autenticacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutenticacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Autenticacions
     * const autenticacion = await prisma.autenticacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AutenticacionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AutenticacionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Autenticacion.
     * @param {AutenticacionUpsertArgs} args - Arguments to update or create a Autenticacion.
     * @example
     * // Update or create a Autenticacion
     * const autenticacion = await prisma.autenticacion.upsert({
     *   create: {
     *     // ... data to create a Autenticacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Autenticacion we want to update
     *   }
     * })
    **/
    upsert<T extends AutenticacionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AutenticacionUpsertArgs<ExtArgs>>
    ): Prisma__AutenticacionClient<$Types.GetResult<AutenticacionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Find zero or more Autenticacions that matches the filter.
     * @param {AutenticacionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const autenticacion = await prisma.autenticacion.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: AutenticacionFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Autenticacion.
     * @param {AutenticacionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const autenticacion = await prisma.autenticacion.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: AutenticacionAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Autenticacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutenticacionCountArgs} args - Arguments to filter Autenticacions to count.
     * @example
     * // Count the number of Autenticacions
     * const count = await prisma.autenticacion.count({
     *   where: {
     *     // ... the filter for the Autenticacions we want to count
     *   }
     * })
    **/
    count<T extends AutenticacionCountArgs>(
      args?: Subset<T, AutenticacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutenticacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Autenticacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutenticacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutenticacionAggregateArgs>(args: Subset<T, AutenticacionAggregateArgs>): Prisma.PrismaPromise<GetAutenticacionAggregateType<T>>

    /**
     * Group by Autenticacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutenticacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutenticacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutenticacionGroupByArgs['orderBy'] }
        : { orderBy?: AutenticacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutenticacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutenticacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Autenticacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AutenticacionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    usuario<T extends UsuarioArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioArgs<ExtArgs>>): Prisma__UsuarioClient<$Types.GetResult<UsuarioPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Autenticacion base type for findUnique actions
   */
  export type AutenticacionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Autenticacion
     */
    select?: AutenticacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AutenticacionInclude<ExtArgs> | null
    /**
     * Filter, which Autenticacion to fetch.
     */
    where: AutenticacionWhereUniqueInput
  }

  /**
   * Autenticacion findUnique
   */
  export interface AutenticacionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AutenticacionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Autenticacion findUniqueOrThrow
   */
  export type AutenticacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Autenticacion
     */
    select?: AutenticacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AutenticacionInclude<ExtArgs> | null
    /**
     * Filter, which Autenticacion to fetch.
     */
    where: AutenticacionWhereUniqueInput
  }


  /**
   * Autenticacion base type for findFirst actions
   */
  export type AutenticacionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Autenticacion
     */
    select?: AutenticacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AutenticacionInclude<ExtArgs> | null
    /**
     * Filter, which Autenticacion to fetch.
     */
    where?: AutenticacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Autenticacions to fetch.
     */
    orderBy?: Enumerable<AutenticacionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Autenticacions.
     */
    cursor?: AutenticacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Autenticacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Autenticacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Autenticacions.
     */
    distinct?: Enumerable<AutenticacionScalarFieldEnum>
  }

  /**
   * Autenticacion findFirst
   */
  export interface AutenticacionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AutenticacionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Autenticacion findFirstOrThrow
   */
  export type AutenticacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Autenticacion
     */
    select?: AutenticacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AutenticacionInclude<ExtArgs> | null
    /**
     * Filter, which Autenticacion to fetch.
     */
    where?: AutenticacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Autenticacions to fetch.
     */
    orderBy?: Enumerable<AutenticacionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Autenticacions.
     */
    cursor?: AutenticacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Autenticacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Autenticacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Autenticacions.
     */
    distinct?: Enumerable<AutenticacionScalarFieldEnum>
  }


  /**
   * Autenticacion findMany
   */
  export type AutenticacionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Autenticacion
     */
    select?: AutenticacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AutenticacionInclude<ExtArgs> | null
    /**
     * Filter, which Autenticacions to fetch.
     */
    where?: AutenticacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Autenticacions to fetch.
     */
    orderBy?: Enumerable<AutenticacionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Autenticacions.
     */
    cursor?: AutenticacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Autenticacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Autenticacions.
     */
    skip?: number
    distinct?: Enumerable<AutenticacionScalarFieldEnum>
  }


  /**
   * Autenticacion create
   */
  export type AutenticacionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Autenticacion
     */
    select?: AutenticacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AutenticacionInclude<ExtArgs> | null
    /**
     * The data needed to create a Autenticacion.
     */
    data: XOR<AutenticacionCreateInput, AutenticacionUncheckedCreateInput>
  }


  /**
   * Autenticacion createMany
   */
  export type AutenticacionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Autenticacions.
     */
    data: Enumerable<AutenticacionCreateManyInput>
  }


  /**
   * Autenticacion update
   */
  export type AutenticacionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Autenticacion
     */
    select?: AutenticacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AutenticacionInclude<ExtArgs> | null
    /**
     * The data needed to update a Autenticacion.
     */
    data: XOR<AutenticacionUpdateInput, AutenticacionUncheckedUpdateInput>
    /**
     * Choose, which Autenticacion to update.
     */
    where: AutenticacionWhereUniqueInput
  }


  /**
   * Autenticacion updateMany
   */
  export type AutenticacionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Autenticacions.
     */
    data: XOR<AutenticacionUpdateManyMutationInput, AutenticacionUncheckedUpdateManyInput>
    /**
     * Filter which Autenticacions to update
     */
    where?: AutenticacionWhereInput
  }


  /**
   * Autenticacion upsert
   */
  export type AutenticacionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Autenticacion
     */
    select?: AutenticacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AutenticacionInclude<ExtArgs> | null
    /**
     * The filter to search for the Autenticacion to update in case it exists.
     */
    where: AutenticacionWhereUniqueInput
    /**
     * In case the Autenticacion found by the `where` argument doesn't exist, create a new Autenticacion with this data.
     */
    create: XOR<AutenticacionCreateInput, AutenticacionUncheckedCreateInput>
    /**
     * In case the Autenticacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutenticacionUpdateInput, AutenticacionUncheckedUpdateInput>
  }


  /**
   * Autenticacion delete
   */
  export type AutenticacionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Autenticacion
     */
    select?: AutenticacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AutenticacionInclude<ExtArgs> | null
    /**
     * Filter which Autenticacion to delete.
     */
    where: AutenticacionWhereUniqueInput
  }


  /**
   * Autenticacion deleteMany
   */
  export type AutenticacionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Autenticacions to delete
     */
    where?: AutenticacionWhereInput
  }


  /**
   * Autenticacion findRaw
   */
  export type AutenticacionFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Autenticacion aggregateRaw
   */
  export type AutenticacionAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Autenticacion without action
   */
  export type AutenticacionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Autenticacion
     */
    select?: AutenticacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AutenticacionInclude<ExtArgs> | null
  }



  /**
   * Model Mensaje
   */


  export type AggregateMensaje = {
    _count: MensajeCountAggregateOutputType | null
    _min: MensajeMinAggregateOutputType | null
    _max: MensajeMaxAggregateOutputType | null
  }

  export type MensajeMinAggregateOutputType = {
    id: string | null
    remitente_id: string | null
    destinatario_id: string | null
    contenido: string | null
    fecha: Date | null
    solicitud_id: string | null
  }

  export type MensajeMaxAggregateOutputType = {
    id: string | null
    remitente_id: string | null
    destinatario_id: string | null
    contenido: string | null
    fecha: Date | null
    solicitud_id: string | null
  }

  export type MensajeCountAggregateOutputType = {
    id: number
    remitente_id: number
    destinatario_id: number
    contenido: number
    fecha: number
    solicitud_id: number
    _all: number
  }


  export type MensajeMinAggregateInputType = {
    id?: true
    remitente_id?: true
    destinatario_id?: true
    contenido?: true
    fecha?: true
    solicitud_id?: true
  }

  export type MensajeMaxAggregateInputType = {
    id?: true
    remitente_id?: true
    destinatario_id?: true
    contenido?: true
    fecha?: true
    solicitud_id?: true
  }

  export type MensajeCountAggregateInputType = {
    id?: true
    remitente_id?: true
    destinatario_id?: true
    contenido?: true
    fecha?: true
    solicitud_id?: true
    _all?: true
  }

  export type MensajeAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mensaje to aggregate.
     */
    where?: MensajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mensajes to fetch.
     */
    orderBy?: Enumerable<MensajeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MensajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mensajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mensajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mensajes
    **/
    _count?: true | MensajeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MensajeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MensajeMaxAggregateInputType
  }

  export type GetMensajeAggregateType<T extends MensajeAggregateArgs> = {
        [P in keyof T & keyof AggregateMensaje]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMensaje[P]>
      : GetScalarType<T[P], AggregateMensaje[P]>
  }




  export type MensajeGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MensajeWhereInput
    orderBy?: Enumerable<MensajeOrderByWithAggregationInput>
    by: MensajeScalarFieldEnum[]
    having?: MensajeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MensajeCountAggregateInputType | true
    _min?: MensajeMinAggregateInputType
    _max?: MensajeMaxAggregateInputType
  }


  export type MensajeGroupByOutputType = {
    id: string
    remitente_id: string
    destinatario_id: string
    contenido: string
    fecha: Date
    solicitud_id: string | null
    _count: MensajeCountAggregateOutputType | null
    _min: MensajeMinAggregateOutputType | null
    _max: MensajeMaxAggregateOutputType | null
  }

  type GetMensajeGroupByPayload<T extends MensajeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MensajeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MensajeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MensajeGroupByOutputType[P]>
            : GetScalarType<T[P], MensajeGroupByOutputType[P]>
        }
      >
    >


  export type MensajeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    remitente_id?: boolean
    destinatario_id?: boolean
    contenido?: boolean
    fecha?: boolean
    solicitud_id?: boolean
    remitente?: boolean | UsuarioArgs<ExtArgs>
    destinatario?: boolean | UsuarioArgs<ExtArgs>
    solicitud?: boolean | SolicitudArgs<ExtArgs>
  }, ExtArgs["result"]["mensaje"]>

  export type MensajeSelectScalar = {
    id?: boolean
    remitente_id?: boolean
    destinatario_id?: boolean
    contenido?: boolean
    fecha?: boolean
    solicitud_id?: boolean
  }

  export type MensajeInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    remitente?: boolean | UsuarioArgs<ExtArgs>
    destinatario?: boolean | UsuarioArgs<ExtArgs>
    solicitud?: boolean | SolicitudArgs<ExtArgs>
  }


  type MensajeGetPayload<S extends boolean | null | undefined | MensajeArgs> = $Types.GetResult<MensajePayload, S>

  type MensajeCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<MensajeFindManyArgs, 'select' | 'include'> & {
      select?: MensajeCountAggregateInputType | true
    }

  export interface MensajeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mensaje'], meta: { name: 'Mensaje' } }
    /**
     * Find zero or one Mensaje that matches the filter.
     * @param {MensajeFindUniqueArgs} args - Arguments to find a Mensaje
     * @example
     * // Get one Mensaje
     * const mensaje = await prisma.mensaje.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MensajeFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MensajeFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Mensaje'> extends True ? Prisma__MensajeClient<$Types.GetResult<MensajePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__MensajeClient<$Types.GetResult<MensajePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Mensaje that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MensajeFindUniqueOrThrowArgs} args - Arguments to find a Mensaje
     * @example
     * // Get one Mensaje
     * const mensaje = await prisma.mensaje.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MensajeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MensajeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MensajeClient<$Types.GetResult<MensajePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Mensaje that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensajeFindFirstArgs} args - Arguments to find a Mensaje
     * @example
     * // Get one Mensaje
     * const mensaje = await prisma.mensaje.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MensajeFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MensajeFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Mensaje'> extends True ? Prisma__MensajeClient<$Types.GetResult<MensajePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__MensajeClient<$Types.GetResult<MensajePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Mensaje that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensajeFindFirstOrThrowArgs} args - Arguments to find a Mensaje
     * @example
     * // Get one Mensaje
     * const mensaje = await prisma.mensaje.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MensajeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MensajeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MensajeClient<$Types.GetResult<MensajePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Mensajes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensajeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mensajes
     * const mensajes = await prisma.mensaje.findMany()
     * 
     * // Get first 10 Mensajes
     * const mensajes = await prisma.mensaje.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mensajeWithIdOnly = await prisma.mensaje.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MensajeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MensajeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<MensajePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Mensaje.
     * @param {MensajeCreateArgs} args - Arguments to create a Mensaje.
     * @example
     * // Create one Mensaje
     * const Mensaje = await prisma.mensaje.create({
     *   data: {
     *     // ... data to create a Mensaje
     *   }
     * })
     * 
    **/
    create<T extends MensajeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MensajeCreateArgs<ExtArgs>>
    ): Prisma__MensajeClient<$Types.GetResult<MensajePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Mensajes.
     *     @param {MensajeCreateManyArgs} args - Arguments to create many Mensajes.
     *     @example
     *     // Create many Mensajes
     *     const mensaje = await prisma.mensaje.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MensajeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MensajeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mensaje.
     * @param {MensajeDeleteArgs} args - Arguments to delete one Mensaje.
     * @example
     * // Delete one Mensaje
     * const Mensaje = await prisma.mensaje.delete({
     *   where: {
     *     // ... filter to delete one Mensaje
     *   }
     * })
     * 
    **/
    delete<T extends MensajeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MensajeDeleteArgs<ExtArgs>>
    ): Prisma__MensajeClient<$Types.GetResult<MensajePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Mensaje.
     * @param {MensajeUpdateArgs} args - Arguments to update one Mensaje.
     * @example
     * // Update one Mensaje
     * const mensaje = await prisma.mensaje.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MensajeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MensajeUpdateArgs<ExtArgs>>
    ): Prisma__MensajeClient<$Types.GetResult<MensajePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Mensajes.
     * @param {MensajeDeleteManyArgs} args - Arguments to filter Mensajes to delete.
     * @example
     * // Delete a few Mensajes
     * const { count } = await prisma.mensaje.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MensajeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MensajeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mensajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensajeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mensajes
     * const mensaje = await prisma.mensaje.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MensajeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MensajeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mensaje.
     * @param {MensajeUpsertArgs} args - Arguments to update or create a Mensaje.
     * @example
     * // Update or create a Mensaje
     * const mensaje = await prisma.mensaje.upsert({
     *   create: {
     *     // ... data to create a Mensaje
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mensaje we want to update
     *   }
     * })
    **/
    upsert<T extends MensajeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MensajeUpsertArgs<ExtArgs>>
    ): Prisma__MensajeClient<$Types.GetResult<MensajePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Find zero or more Mensajes that matches the filter.
     * @param {MensajeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const mensaje = await prisma.mensaje.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: MensajeFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Mensaje.
     * @param {MensajeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const mensaje = await prisma.mensaje.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: MensajeAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Mensajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensajeCountArgs} args - Arguments to filter Mensajes to count.
     * @example
     * // Count the number of Mensajes
     * const count = await prisma.mensaje.count({
     *   where: {
     *     // ... the filter for the Mensajes we want to count
     *   }
     * })
    **/
    count<T extends MensajeCountArgs>(
      args?: Subset<T, MensajeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MensajeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mensaje.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensajeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MensajeAggregateArgs>(args: Subset<T, MensajeAggregateArgs>): Prisma.PrismaPromise<GetMensajeAggregateType<T>>

    /**
     * Group by Mensaje.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensajeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MensajeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MensajeGroupByArgs['orderBy'] }
        : { orderBy?: MensajeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MensajeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMensajeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Mensaje.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MensajeClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    remitente<T extends UsuarioArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioArgs<ExtArgs>>): Prisma__UsuarioClient<$Types.GetResult<UsuarioPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    destinatario<T extends UsuarioArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioArgs<ExtArgs>>): Prisma__UsuarioClient<$Types.GetResult<UsuarioPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    solicitud<T extends SolicitudArgs<ExtArgs> = {}>(args?: Subset<T, SolicitudArgs<ExtArgs>>): Prisma__SolicitudClient<$Types.GetResult<SolicitudPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Mensaje base type for findUnique actions
   */
  export type MensajeFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensajeInclude<ExtArgs> | null
    /**
     * Filter, which Mensaje to fetch.
     */
    where: MensajeWhereUniqueInput
  }

  /**
   * Mensaje findUnique
   */
  export interface MensajeFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends MensajeFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Mensaje findUniqueOrThrow
   */
  export type MensajeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensajeInclude<ExtArgs> | null
    /**
     * Filter, which Mensaje to fetch.
     */
    where: MensajeWhereUniqueInput
  }


  /**
   * Mensaje base type for findFirst actions
   */
  export type MensajeFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensajeInclude<ExtArgs> | null
    /**
     * Filter, which Mensaje to fetch.
     */
    where?: MensajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mensajes to fetch.
     */
    orderBy?: Enumerable<MensajeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mensajes.
     */
    cursor?: MensajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mensajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mensajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mensajes.
     */
    distinct?: Enumerable<MensajeScalarFieldEnum>
  }

  /**
   * Mensaje findFirst
   */
  export interface MensajeFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends MensajeFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Mensaje findFirstOrThrow
   */
  export type MensajeFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensajeInclude<ExtArgs> | null
    /**
     * Filter, which Mensaje to fetch.
     */
    where?: MensajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mensajes to fetch.
     */
    orderBy?: Enumerable<MensajeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mensajes.
     */
    cursor?: MensajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mensajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mensajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mensajes.
     */
    distinct?: Enumerable<MensajeScalarFieldEnum>
  }


  /**
   * Mensaje findMany
   */
  export type MensajeFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensajeInclude<ExtArgs> | null
    /**
     * Filter, which Mensajes to fetch.
     */
    where?: MensajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mensajes to fetch.
     */
    orderBy?: Enumerable<MensajeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mensajes.
     */
    cursor?: MensajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mensajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mensajes.
     */
    skip?: number
    distinct?: Enumerable<MensajeScalarFieldEnum>
  }


  /**
   * Mensaje create
   */
  export type MensajeCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensajeInclude<ExtArgs> | null
    /**
     * The data needed to create a Mensaje.
     */
    data: XOR<MensajeCreateInput, MensajeUncheckedCreateInput>
  }


  /**
   * Mensaje createMany
   */
  export type MensajeCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mensajes.
     */
    data: Enumerable<MensajeCreateManyInput>
  }


  /**
   * Mensaje update
   */
  export type MensajeUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensajeInclude<ExtArgs> | null
    /**
     * The data needed to update a Mensaje.
     */
    data: XOR<MensajeUpdateInput, MensajeUncheckedUpdateInput>
    /**
     * Choose, which Mensaje to update.
     */
    where: MensajeWhereUniqueInput
  }


  /**
   * Mensaje updateMany
   */
  export type MensajeUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mensajes.
     */
    data: XOR<MensajeUpdateManyMutationInput, MensajeUncheckedUpdateManyInput>
    /**
     * Filter which Mensajes to update
     */
    where?: MensajeWhereInput
  }


  /**
   * Mensaje upsert
   */
  export type MensajeUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensajeInclude<ExtArgs> | null
    /**
     * The filter to search for the Mensaje to update in case it exists.
     */
    where: MensajeWhereUniqueInput
    /**
     * In case the Mensaje found by the `where` argument doesn't exist, create a new Mensaje with this data.
     */
    create: XOR<MensajeCreateInput, MensajeUncheckedCreateInput>
    /**
     * In case the Mensaje was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MensajeUpdateInput, MensajeUncheckedUpdateInput>
  }


  /**
   * Mensaje delete
   */
  export type MensajeDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensajeInclude<ExtArgs> | null
    /**
     * Filter which Mensaje to delete.
     */
    where: MensajeWhereUniqueInput
  }


  /**
   * Mensaje deleteMany
   */
  export type MensajeDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mensajes to delete
     */
    where?: MensajeWhereInput
  }


  /**
   * Mensaje findRaw
   */
  export type MensajeFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Mensaje aggregateRaw
   */
  export type MensajeAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Mensaje without action
   */
  export type MensajeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensajeInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    correo_electronico: 'correo_electronico',
    contrasena: 'contrasena',
    telefono: 'telefono',
    direccion: 'direccion',
    es_cuidador: 'es_cuidador',
    fecha_registro: 'fecha_registro'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const CuidadorScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    experiencia: 'experiencia',
    tipo_servicios: 'tipo_servicios',
    calificacion_promedio: 'calificacion_promedio',
    cantidad_servicios: 'cantidad_servicios'
  };

  export type CuidadorScalarFieldEnum = (typeof CuidadorScalarFieldEnum)[keyof typeof CuidadorScalarFieldEnum]


  export const ServicioScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    precio_base: 'precio_base'
  };

  export type ServicioScalarFieldEnum = (typeof ServicioScalarFieldEnum)[keyof typeof ServicioScalarFieldEnum]


  export const DisponibilidadScalarFieldEnum: {
    id: 'id',
    cuidador_id: 'cuidador_id',
    fecha_disponible: 'fecha_disponible',
    servicio_id: 'servicio_id'
  };

  export type DisponibilidadScalarFieldEnum = (typeof DisponibilidadScalarFieldEnum)[keyof typeof DisponibilidadScalarFieldEnum]


  export const SolicitudScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    cuidador_id: 'cuidador_id',
    servicio_id: 'servicio_id',
    fecha_solicitada: 'fecha_solicitada',
    estado: 'estado',
    fecha_respuesta: 'fecha_respuesta'
  };

  export type SolicitudScalarFieldEnum = (typeof SolicitudScalarFieldEnum)[keyof typeof SolicitudScalarFieldEnum]


  export const ComentarioScalarFieldEnum: {
    id: 'id',
    solicitud_id: 'solicitud_id',
    usuario_id: 'usuario_id',
    calificacion: 'calificacion',
    comentario: 'comentario',
    fecha: 'fecha'
  };

  export type ComentarioScalarFieldEnum = (typeof ComentarioScalarFieldEnum)[keyof typeof ComentarioScalarFieldEnum]


  export const AutenticacionScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    token: 'token',
    expiracion: 'expiracion',
    tipo: 'tipo'
  };

  export type AutenticacionScalarFieldEnum = (typeof AutenticacionScalarFieldEnum)[keyof typeof AutenticacionScalarFieldEnum]


  export const MensajeScalarFieldEnum: {
    id: 'id',
    remitente_id: 'remitente_id',
    destinatario_id: 'destinatario_id',
    contenido: 'contenido',
    fecha: 'fecha',
    solicitud_id: 'solicitud_id'
  };

  export type MensajeScalarFieldEnum = (typeof MensajeScalarFieldEnum)[keyof typeof MensajeScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type UsuarioWhereInput = {
    AND?: Enumerable<UsuarioWhereInput>
    OR?: Enumerable<UsuarioWhereInput>
    NOT?: Enumerable<UsuarioWhereInput>
    id?: StringFilter | string
    nombre?: StringFilter | string
    correo_electronico?: StringFilter | string
    contrasena?: StringFilter | string
    telefono?: StringNullableFilter | string | null
    direccion?: StringNullableFilter | string | null
    es_cuidador?: BoolFilter | boolean
    fecha_registro?: DateTimeFilter | Date | string
    cuidador?: XOR<CuidadorRelationFilter, CuidadorWhereInput> | null
    solicitudes?: SolicitudListRelationFilter
    comentarios?: ComentarioListRelationFilter
    autenticacion?: AutenticacionListRelationFilter
    mensajes_enviados?: MensajeListRelationFilter
    mensajes_recibidos?: MensajeListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    correo_electronico?: SortOrder
    contrasena?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    es_cuidador?: SortOrder
    fecha_registro?: SortOrder
    cuidador?: CuidadorOrderByWithRelationInput
    solicitudes?: SolicitudOrderByRelationAggregateInput
    comentarios?: ComentarioOrderByRelationAggregateInput
    autenticacion?: AutenticacionOrderByRelationAggregateInput
    mensajes_enviados?: MensajeOrderByRelationAggregateInput
    mensajes_recibidos?: MensajeOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = {
    id?: string
    correo_electronico?: string
  }

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    correo_electronico?: SortOrder
    contrasena?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    es_cuidador?: SortOrder
    fecha_registro?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UsuarioScalarWhereWithAggregatesInput>
    OR?: Enumerable<UsuarioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UsuarioScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    nombre?: StringWithAggregatesFilter | string
    correo_electronico?: StringWithAggregatesFilter | string
    contrasena?: StringWithAggregatesFilter | string
    telefono?: StringNullableWithAggregatesFilter | string | null
    direccion?: StringNullableWithAggregatesFilter | string | null
    es_cuidador?: BoolWithAggregatesFilter | boolean
    fecha_registro?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CuidadorWhereInput = {
    AND?: Enumerable<CuidadorWhereInput>
    OR?: Enumerable<CuidadorWhereInput>
    NOT?: Enumerable<CuidadorWhereInput>
    id?: StringFilter | string
    usuario_id?: StringFilter | string
    experiencia?: StringNullableFilter | string | null
    tipo_servicios?: StringNullableListFilter
    calificacion_promedio?: FloatNullableFilter | number | null
    cantidad_servicios?: IntFilter | number
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    disponibilidades?: DisponibilidadListRelationFilter
    solicitudes?: SolicitudListRelationFilter
  }

  export type CuidadorOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    experiencia?: SortOrder
    tipo_servicios?: SortOrder
    calificacion_promedio?: SortOrder
    cantidad_servicios?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    disponibilidades?: DisponibilidadOrderByRelationAggregateInput
    solicitudes?: SolicitudOrderByRelationAggregateInput
  }

  export type CuidadorWhereUniqueInput = {
    id?: string
    usuario_id?: string
  }

  export type CuidadorOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    experiencia?: SortOrder
    tipo_servicios?: SortOrder
    calificacion_promedio?: SortOrder
    cantidad_servicios?: SortOrder
    _count?: CuidadorCountOrderByAggregateInput
    _avg?: CuidadorAvgOrderByAggregateInput
    _max?: CuidadorMaxOrderByAggregateInput
    _min?: CuidadorMinOrderByAggregateInput
    _sum?: CuidadorSumOrderByAggregateInput
  }

  export type CuidadorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CuidadorScalarWhereWithAggregatesInput>
    OR?: Enumerable<CuidadorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CuidadorScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    usuario_id?: StringWithAggregatesFilter | string
    experiencia?: StringNullableWithAggregatesFilter | string | null
    tipo_servicios?: StringNullableListFilter
    calificacion_promedio?: FloatNullableWithAggregatesFilter | number | null
    cantidad_servicios?: IntWithAggregatesFilter | number
  }

  export type ServicioWhereInput = {
    AND?: Enumerable<ServicioWhereInput>
    OR?: Enumerable<ServicioWhereInput>
    NOT?: Enumerable<ServicioWhereInput>
    id?: StringFilter | string
    nombre?: StringFilter | string
    descripcion?: StringNullableFilter | string | null
    precio_base?: FloatNullableFilter | number | null
    disponibilidades?: DisponibilidadListRelationFilter
    solicitudes?: SolicitudListRelationFilter
  }

  export type ServicioOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precio_base?: SortOrder
    disponibilidades?: DisponibilidadOrderByRelationAggregateInput
    solicitudes?: SolicitudOrderByRelationAggregateInput
  }

  export type ServicioWhereUniqueInput = {
    id?: string
  }

  export type ServicioOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precio_base?: SortOrder
    _count?: ServicioCountOrderByAggregateInput
    _avg?: ServicioAvgOrderByAggregateInput
    _max?: ServicioMaxOrderByAggregateInput
    _min?: ServicioMinOrderByAggregateInput
    _sum?: ServicioSumOrderByAggregateInput
  }

  export type ServicioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServicioScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServicioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServicioScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    nombre?: StringWithAggregatesFilter | string
    descripcion?: StringNullableWithAggregatesFilter | string | null
    precio_base?: FloatNullableWithAggregatesFilter | number | null
  }

  export type DisponibilidadWhereInput = {
    AND?: Enumerable<DisponibilidadWhereInput>
    OR?: Enumerable<DisponibilidadWhereInput>
    NOT?: Enumerable<DisponibilidadWhereInput>
    id?: StringFilter | string
    cuidador_id?: StringFilter | string
    fecha_disponible?: DateTimeFilter | Date | string
    servicio_id?: StringFilter | string
    cuidador?: XOR<CuidadorRelationFilter, CuidadorWhereInput>
    servicio?: XOR<ServicioRelationFilter, ServicioWhereInput>
  }

  export type DisponibilidadOrderByWithRelationInput = {
    id?: SortOrder
    cuidador_id?: SortOrder
    fecha_disponible?: SortOrder
    servicio_id?: SortOrder
    cuidador?: CuidadorOrderByWithRelationInput
    servicio?: ServicioOrderByWithRelationInput
  }

  export type DisponibilidadWhereUniqueInput = {
    id?: string
  }

  export type DisponibilidadOrderByWithAggregationInput = {
    id?: SortOrder
    cuidador_id?: SortOrder
    fecha_disponible?: SortOrder
    servicio_id?: SortOrder
    _count?: DisponibilidadCountOrderByAggregateInput
    _max?: DisponibilidadMaxOrderByAggregateInput
    _min?: DisponibilidadMinOrderByAggregateInput
  }

  export type DisponibilidadScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DisponibilidadScalarWhereWithAggregatesInput>
    OR?: Enumerable<DisponibilidadScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DisponibilidadScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    cuidador_id?: StringWithAggregatesFilter | string
    fecha_disponible?: DateTimeWithAggregatesFilter | Date | string
    servicio_id?: StringWithAggregatesFilter | string
  }

  export type SolicitudWhereInput = {
    AND?: Enumerable<SolicitudWhereInput>
    OR?: Enumerable<SolicitudWhereInput>
    NOT?: Enumerable<SolicitudWhereInput>
    id?: StringFilter | string
    usuario_id?: StringFilter | string
    cuidador_id?: StringFilter | string
    servicio_id?: StringFilter | string
    fecha_solicitada?: DateTimeFilter | Date | string
    estado?: StringFilter | string
    fecha_respuesta?: DateTimeNullableFilter | Date | string | null
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    cuidador?: XOR<CuidadorRelationFilter, CuidadorWhereInput>
    servicio?: XOR<ServicioRelationFilter, ServicioWhereInput>
    comentario?: XOR<ComentarioRelationFilter, ComentarioWhereInput> | null
    mensajes?: MensajeListRelationFilter
  }

  export type SolicitudOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    cuidador_id?: SortOrder
    servicio_id?: SortOrder
    fecha_solicitada?: SortOrder
    estado?: SortOrder
    fecha_respuesta?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    cuidador?: CuidadorOrderByWithRelationInput
    servicio?: ServicioOrderByWithRelationInput
    comentario?: ComentarioOrderByWithRelationInput
    mensajes?: MensajeOrderByRelationAggregateInput
  }

  export type SolicitudWhereUniqueInput = {
    id?: string
  }

  export type SolicitudOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    cuidador_id?: SortOrder
    servicio_id?: SortOrder
    fecha_solicitada?: SortOrder
    estado?: SortOrder
    fecha_respuesta?: SortOrder
    _count?: SolicitudCountOrderByAggregateInput
    _max?: SolicitudMaxOrderByAggregateInput
    _min?: SolicitudMinOrderByAggregateInput
  }

  export type SolicitudScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SolicitudScalarWhereWithAggregatesInput>
    OR?: Enumerable<SolicitudScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SolicitudScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    usuario_id?: StringWithAggregatesFilter | string
    cuidador_id?: StringWithAggregatesFilter | string
    servicio_id?: StringWithAggregatesFilter | string
    fecha_solicitada?: DateTimeWithAggregatesFilter | Date | string
    estado?: StringWithAggregatesFilter | string
    fecha_respuesta?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ComentarioWhereInput = {
    AND?: Enumerable<ComentarioWhereInput>
    OR?: Enumerable<ComentarioWhereInput>
    NOT?: Enumerable<ComentarioWhereInput>
    id?: StringFilter | string
    solicitud_id?: StringFilter | string
    usuario_id?: StringFilter | string
    calificacion?: IntFilter | number
    comentario?: StringNullableFilter | string | null
    fecha?: DateTimeFilter | Date | string
    solicitud?: XOR<SolicitudRelationFilter, SolicitudWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type ComentarioOrderByWithRelationInput = {
    id?: SortOrder
    solicitud_id?: SortOrder
    usuario_id?: SortOrder
    calificacion?: SortOrder
    comentario?: SortOrder
    fecha?: SortOrder
    solicitud?: SolicitudOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type ComentarioWhereUniqueInput = {
    id?: string
    solicitud_id?: string
  }

  export type ComentarioOrderByWithAggregationInput = {
    id?: SortOrder
    solicitud_id?: SortOrder
    usuario_id?: SortOrder
    calificacion?: SortOrder
    comentario?: SortOrder
    fecha?: SortOrder
    _count?: ComentarioCountOrderByAggregateInput
    _avg?: ComentarioAvgOrderByAggregateInput
    _max?: ComentarioMaxOrderByAggregateInput
    _min?: ComentarioMinOrderByAggregateInput
    _sum?: ComentarioSumOrderByAggregateInput
  }

  export type ComentarioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ComentarioScalarWhereWithAggregatesInput>
    OR?: Enumerable<ComentarioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ComentarioScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    solicitud_id?: StringWithAggregatesFilter | string
    usuario_id?: StringWithAggregatesFilter | string
    calificacion?: IntWithAggregatesFilter | number
    comentario?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AutenticacionWhereInput = {
    AND?: Enumerable<AutenticacionWhereInput>
    OR?: Enumerable<AutenticacionWhereInput>
    NOT?: Enumerable<AutenticacionWhereInput>
    id?: StringFilter | string
    usuario_id?: StringFilter | string
    token?: StringFilter | string
    expiracion?: DateTimeFilter | Date | string
    tipo?: StringFilter | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type AutenticacionOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    token?: SortOrder
    expiracion?: SortOrder
    tipo?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type AutenticacionWhereUniqueInput = {
    id?: string
    token?: string
  }

  export type AutenticacionOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    token?: SortOrder
    expiracion?: SortOrder
    tipo?: SortOrder
    _count?: AutenticacionCountOrderByAggregateInput
    _max?: AutenticacionMaxOrderByAggregateInput
    _min?: AutenticacionMinOrderByAggregateInput
  }

  export type AutenticacionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AutenticacionScalarWhereWithAggregatesInput>
    OR?: Enumerable<AutenticacionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AutenticacionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    usuario_id?: StringWithAggregatesFilter | string
    token?: StringWithAggregatesFilter | string
    expiracion?: DateTimeWithAggregatesFilter | Date | string
    tipo?: StringWithAggregatesFilter | string
  }

  export type MensajeWhereInput = {
    AND?: Enumerable<MensajeWhereInput>
    OR?: Enumerable<MensajeWhereInput>
    NOT?: Enumerable<MensajeWhereInput>
    id?: StringFilter | string
    remitente_id?: StringFilter | string
    destinatario_id?: StringFilter | string
    contenido?: StringFilter | string
    fecha?: DateTimeFilter | Date | string
    solicitud_id?: StringNullableFilter | string | null
    remitente?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    destinatario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    solicitud?: XOR<SolicitudRelationFilter, SolicitudWhereInput> | null
  }

  export type MensajeOrderByWithRelationInput = {
    id?: SortOrder
    remitente_id?: SortOrder
    destinatario_id?: SortOrder
    contenido?: SortOrder
    fecha?: SortOrder
    solicitud_id?: SortOrder
    remitente?: UsuarioOrderByWithRelationInput
    destinatario?: UsuarioOrderByWithRelationInput
    solicitud?: SolicitudOrderByWithRelationInput
  }

  export type MensajeWhereUniqueInput = {
    id?: string
  }

  export type MensajeOrderByWithAggregationInput = {
    id?: SortOrder
    remitente_id?: SortOrder
    destinatario_id?: SortOrder
    contenido?: SortOrder
    fecha?: SortOrder
    solicitud_id?: SortOrder
    _count?: MensajeCountOrderByAggregateInput
    _max?: MensajeMaxOrderByAggregateInput
    _min?: MensajeMinOrderByAggregateInput
  }

  export type MensajeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MensajeScalarWhereWithAggregatesInput>
    OR?: Enumerable<MensajeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MensajeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    remitente_id?: StringWithAggregatesFilter | string
    destinatario_id?: StringWithAggregatesFilter | string
    contenido?: StringWithAggregatesFilter | string
    fecha?: DateTimeWithAggregatesFilter | Date | string
    solicitud_id?: StringNullableWithAggregatesFilter | string | null
  }

  export type UsuarioCreateInput = {
    id?: string
    nombre: string
    correo_electronico: string
    contrasena: string
    telefono?: string | null
    direccion?: string | null
    es_cuidador?: boolean
    fecha_registro?: Date | string
    cuidador?: CuidadorCreateNestedOneWithoutUsuarioInput
    solicitudes?: SolicitudCreateNestedManyWithoutUsuarioInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    autenticacion?: AutenticacionCreateNestedManyWithoutUsuarioInput
    mensajes_enviados?: MensajeCreateNestedManyWithoutRemitenteInput
    mensajes_recibidos?: MensajeCreateNestedManyWithoutDestinatarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: string
    nombre: string
    correo_electronico: string
    contrasena: string
    telefono?: string | null
    direccion?: string | null
    es_cuidador?: boolean
    fecha_registro?: Date | string
    cuidador?: CuidadorUncheckedCreateNestedOneWithoutUsuarioInput
    solicitudes?: SolicitudUncheckedCreateNestedManyWithoutUsuarioInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    autenticacion?: AutenticacionUncheckedCreateNestedManyWithoutUsuarioInput
    mensajes_enviados?: MensajeUncheckedCreateNestedManyWithoutRemitenteInput
    mensajes_recibidos?: MensajeUncheckedCreateNestedManyWithoutDestinatarioInput
  }

  export type UsuarioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    es_cuidador?: BoolFieldUpdateOperationsInput | boolean
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    cuidador?: CuidadorUpdateOneWithoutUsuarioNestedInput
    solicitudes?: SolicitudUpdateManyWithoutUsuarioNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    autenticacion?: AutenticacionUpdateManyWithoutUsuarioNestedInput
    mensajes_enviados?: MensajeUpdateManyWithoutRemitenteNestedInput
    mensajes_recibidos?: MensajeUpdateManyWithoutDestinatarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    es_cuidador?: BoolFieldUpdateOperationsInput | boolean
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    cuidador?: CuidadorUncheckedUpdateOneWithoutUsuarioNestedInput
    solicitudes?: SolicitudUncheckedUpdateManyWithoutUsuarioNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    autenticacion?: AutenticacionUncheckedUpdateManyWithoutUsuarioNestedInput
    mensajes_enviados?: MensajeUncheckedUpdateManyWithoutRemitenteNestedInput
    mensajes_recibidos?: MensajeUncheckedUpdateManyWithoutDestinatarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: string
    nombre: string
    correo_electronico: string
    contrasena: string
    telefono?: string | null
    direccion?: string | null
    es_cuidador?: boolean
    fecha_registro?: Date | string
  }

  export type UsuarioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    es_cuidador?: BoolFieldUpdateOperationsInput | boolean
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    es_cuidador?: BoolFieldUpdateOperationsInput | boolean
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CuidadorCreateInput = {
    id?: string
    experiencia?: string | null
    tipo_servicios?: CuidadorCreatetipo_serviciosInput | Enumerable<string>
    calificacion_promedio?: number | null
    cantidad_servicios?: number
    usuario: UsuarioCreateNestedOneWithoutCuidadorInput
    disponibilidades?: DisponibilidadCreateNestedManyWithoutCuidadorInput
    solicitudes?: SolicitudCreateNestedManyWithoutCuidadorInput
  }

  export type CuidadorUncheckedCreateInput = {
    id?: string
    usuario_id: string
    experiencia?: string | null
    tipo_servicios?: CuidadorCreatetipo_serviciosInput | Enumerable<string>
    calificacion_promedio?: number | null
    cantidad_servicios?: number
    disponibilidades?: DisponibilidadUncheckedCreateNestedManyWithoutCuidadorInput
    solicitudes?: SolicitudUncheckedCreateNestedManyWithoutCuidadorInput
  }

  export type CuidadorUpdateInput = {
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_servicios?: CuidadorUpdatetipo_serviciosInput | Enumerable<string>
    calificacion_promedio?: NullableFloatFieldUpdateOperationsInput | number | null
    cantidad_servicios?: IntFieldUpdateOperationsInput | number
    usuario?: UsuarioUpdateOneRequiredWithoutCuidadorNestedInput
    disponibilidades?: DisponibilidadUpdateManyWithoutCuidadorNestedInput
    solicitudes?: SolicitudUpdateManyWithoutCuidadorNestedInput
  }

  export type CuidadorUncheckedUpdateInput = {
    usuario_id?: StringFieldUpdateOperationsInput | string
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_servicios?: CuidadorUpdatetipo_serviciosInput | Enumerable<string>
    calificacion_promedio?: NullableFloatFieldUpdateOperationsInput | number | null
    cantidad_servicios?: IntFieldUpdateOperationsInput | number
    disponibilidades?: DisponibilidadUncheckedUpdateManyWithoutCuidadorNestedInput
    solicitudes?: SolicitudUncheckedUpdateManyWithoutCuidadorNestedInput
  }

  export type CuidadorCreateManyInput = {
    id?: string
    usuario_id: string
    experiencia?: string | null
    tipo_servicios?: CuidadorCreatetipo_serviciosInput | Enumerable<string>
    calificacion_promedio?: number | null
    cantidad_servicios?: number
  }

  export type CuidadorUpdateManyMutationInput = {
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_servicios?: CuidadorUpdatetipo_serviciosInput | Enumerable<string>
    calificacion_promedio?: NullableFloatFieldUpdateOperationsInput | number | null
    cantidad_servicios?: IntFieldUpdateOperationsInput | number
  }

  export type CuidadorUncheckedUpdateManyInput = {
    usuario_id?: StringFieldUpdateOperationsInput | string
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_servicios?: CuidadorUpdatetipo_serviciosInput | Enumerable<string>
    calificacion_promedio?: NullableFloatFieldUpdateOperationsInput | number | null
    cantidad_servicios?: IntFieldUpdateOperationsInput | number
  }

  export type ServicioCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    precio_base?: number | null
    disponibilidades?: DisponibilidadCreateNestedManyWithoutServicioInput
    solicitudes?: SolicitudCreateNestedManyWithoutServicioInput
  }

  export type ServicioUncheckedCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    precio_base?: number | null
    disponibilidades?: DisponibilidadUncheckedCreateNestedManyWithoutServicioInput
    solicitudes?: SolicitudUncheckedCreateNestedManyWithoutServicioInput
  }

  export type ServicioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio_base?: NullableFloatFieldUpdateOperationsInput | number | null
    disponibilidades?: DisponibilidadUpdateManyWithoutServicioNestedInput
    solicitudes?: SolicitudUpdateManyWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio_base?: NullableFloatFieldUpdateOperationsInput | number | null
    disponibilidades?: DisponibilidadUncheckedUpdateManyWithoutServicioNestedInput
    solicitudes?: SolicitudUncheckedUpdateManyWithoutServicioNestedInput
  }

  export type ServicioCreateManyInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    precio_base?: number | null
  }

  export type ServicioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio_base?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ServicioUncheckedUpdateManyInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio_base?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DisponibilidadCreateInput = {
    id?: string
    fecha_disponible: Date | string
    cuidador: CuidadorCreateNestedOneWithoutDisponibilidadesInput
    servicio: ServicioCreateNestedOneWithoutDisponibilidadesInput
  }

  export type DisponibilidadUncheckedCreateInput = {
    id?: string
    cuidador_id: string
    fecha_disponible: Date | string
    servicio_id: string
  }

  export type DisponibilidadUpdateInput = {
    fecha_disponible?: DateTimeFieldUpdateOperationsInput | Date | string
    cuidador?: CuidadorUpdateOneRequiredWithoutDisponibilidadesNestedInput
    servicio?: ServicioUpdateOneRequiredWithoutDisponibilidadesNestedInput
  }

  export type DisponibilidadUncheckedUpdateInput = {
    cuidador_id?: StringFieldUpdateOperationsInput | string
    fecha_disponible?: DateTimeFieldUpdateOperationsInput | Date | string
    servicio_id?: StringFieldUpdateOperationsInput | string
  }

  export type DisponibilidadCreateManyInput = {
    id?: string
    cuidador_id: string
    fecha_disponible: Date | string
    servicio_id: string
  }

  export type DisponibilidadUpdateManyMutationInput = {
    fecha_disponible?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisponibilidadUncheckedUpdateManyInput = {
    cuidador_id?: StringFieldUpdateOperationsInput | string
    fecha_disponible?: DateTimeFieldUpdateOperationsInput | Date | string
    servicio_id?: StringFieldUpdateOperationsInput | string
  }

  export type SolicitudCreateInput = {
    id?: string
    fecha_solicitada?: Date | string
    estado: string
    fecha_respuesta?: Date | string | null
    usuario: UsuarioCreateNestedOneWithoutSolicitudesInput
    cuidador: CuidadorCreateNestedOneWithoutSolicitudesInput
    servicio: ServicioCreateNestedOneWithoutSolicitudesInput
    comentario?: ComentarioCreateNestedOneWithoutSolicitudInput
    mensajes?: MensajeCreateNestedManyWithoutSolicitudInput
  }

  export type SolicitudUncheckedCreateInput = {
    id?: string
    usuario_id: string
    cuidador_id: string
    servicio_id: string
    fecha_solicitada?: Date | string
    estado: string
    fecha_respuesta?: Date | string | null
    comentario?: ComentarioUncheckedCreateNestedOneWithoutSolicitudInput
    mensajes?: MensajeUncheckedCreateNestedManyWithoutSolicitudInput
  }

  export type SolicitudUpdateInput = {
    fecha_solicitada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_respuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuario?: UsuarioUpdateOneRequiredWithoutSolicitudesNestedInput
    cuidador?: CuidadorUpdateOneRequiredWithoutSolicitudesNestedInput
    servicio?: ServicioUpdateOneRequiredWithoutSolicitudesNestedInput
    comentario?: ComentarioUpdateOneWithoutSolicitudNestedInput
    mensajes?: MensajeUpdateManyWithoutSolicitudNestedInput
  }

  export type SolicitudUncheckedUpdateInput = {
    usuario_id?: StringFieldUpdateOperationsInput | string
    cuidador_id?: StringFieldUpdateOperationsInput | string
    servicio_id?: StringFieldUpdateOperationsInput | string
    fecha_solicitada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_respuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comentario?: ComentarioUncheckedUpdateOneWithoutSolicitudNestedInput
    mensajes?: MensajeUncheckedUpdateManyWithoutSolicitudNestedInput
  }

  export type SolicitudCreateManyInput = {
    id?: string
    usuario_id: string
    cuidador_id: string
    servicio_id: string
    fecha_solicitada?: Date | string
    estado: string
    fecha_respuesta?: Date | string | null
  }

  export type SolicitudUpdateManyMutationInput = {
    fecha_solicitada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_respuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SolicitudUncheckedUpdateManyInput = {
    usuario_id?: StringFieldUpdateOperationsInput | string
    cuidador_id?: StringFieldUpdateOperationsInput | string
    servicio_id?: StringFieldUpdateOperationsInput | string
    fecha_solicitada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_respuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ComentarioCreateInput = {
    id?: string
    calificacion: number
    comentario?: string | null
    fecha?: Date | string
    solicitud: SolicitudCreateNestedOneWithoutComentarioInput
    usuario: UsuarioCreateNestedOneWithoutComentariosInput
  }

  export type ComentarioUncheckedCreateInput = {
    id?: string
    solicitud_id: string
    usuario_id: string
    calificacion: number
    comentario?: string | null
    fecha?: Date | string
  }

  export type ComentarioUpdateInput = {
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    solicitud?: SolicitudUpdateOneRequiredWithoutComentarioNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type ComentarioUncheckedUpdateInput = {
    solicitud_id?: StringFieldUpdateOperationsInput | string
    usuario_id?: StringFieldUpdateOperationsInput | string
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentarioCreateManyInput = {
    id?: string
    solicitud_id: string
    usuario_id: string
    calificacion: number
    comentario?: string | null
    fecha?: Date | string
  }

  export type ComentarioUpdateManyMutationInput = {
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentarioUncheckedUpdateManyInput = {
    solicitud_id?: StringFieldUpdateOperationsInput | string
    usuario_id?: StringFieldUpdateOperationsInput | string
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutenticacionCreateInput = {
    id?: string
    token: string
    expiracion: Date | string
    tipo: string
    usuario: UsuarioCreateNestedOneWithoutAutenticacionInput
  }

  export type AutenticacionUncheckedCreateInput = {
    id?: string
    usuario_id: string
    token: string
    expiracion: Date | string
    tipo: string
  }

  export type AutenticacionUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
    usuario?: UsuarioUpdateOneRequiredWithoutAutenticacionNestedInput
  }

  export type AutenticacionUncheckedUpdateInput = {
    usuario_id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type AutenticacionCreateManyInput = {
    id?: string
    usuario_id: string
    token: string
    expiracion: Date | string
    tipo: string
  }

  export type AutenticacionUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type AutenticacionUncheckedUpdateManyInput = {
    usuario_id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type MensajeCreateInput = {
    id?: string
    contenido: string
    fecha?: Date | string
    remitente: UsuarioCreateNestedOneWithoutMensajes_enviadosInput
    destinatario: UsuarioCreateNestedOneWithoutMensajes_recibidosInput
    solicitud?: SolicitudCreateNestedOneWithoutMensajesInput
  }

  export type MensajeUncheckedCreateInput = {
    id?: string
    remitente_id: string
    destinatario_id: string
    contenido: string
    fecha?: Date | string
    solicitud_id?: string | null
  }

  export type MensajeUpdateInput = {
    contenido?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    remitente?: UsuarioUpdateOneRequiredWithoutMensajes_enviadosNestedInput
    destinatario?: UsuarioUpdateOneRequiredWithoutMensajes_recibidosNestedInput
    solicitud?: SolicitudUpdateOneWithoutMensajesNestedInput
  }

  export type MensajeUncheckedUpdateInput = {
    remitente_id?: StringFieldUpdateOperationsInput | string
    destinatario_id?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    solicitud_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MensajeCreateManyInput = {
    id?: string
    remitente_id: string
    destinatario_id: string
    contenido: string
    fecha?: Date | string
    solicitud_id?: string | null
  }

  export type MensajeUpdateManyMutationInput = {
    contenido?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MensajeUncheckedUpdateManyInput = {
    remitente_id?: StringFieldUpdateOperationsInput | string
    destinatario_id?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    solicitud_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
    isSet?: boolean
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type CuidadorRelationFilter = {
    is?: CuidadorWhereInput | null
    isNot?: CuidadorWhereInput | null
  }

  export type SolicitudListRelationFilter = {
    every?: SolicitudWhereInput
    some?: SolicitudWhereInput
    none?: SolicitudWhereInput
  }

  export type ComentarioListRelationFilter = {
    every?: ComentarioWhereInput
    some?: ComentarioWhereInput
    none?: ComentarioWhereInput
  }

  export type AutenticacionListRelationFilter = {
    every?: AutenticacionWhereInput
    some?: AutenticacionWhereInput
    none?: AutenticacionWhereInput
  }

  export type MensajeListRelationFilter = {
    every?: MensajeWhereInput
    some?: MensajeWhereInput
    none?: MensajeWhereInput
  }

  export type SolicitudOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComentarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutenticacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MensajeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    correo_electronico?: SortOrder
    contrasena?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    es_cuidador?: SortOrder
    fecha_registro?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    correo_electronico?: SortOrder
    contrasena?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    es_cuidador?: SortOrder
    fecha_registro?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    correo_electronico?: SortOrder
    contrasena?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    es_cuidador?: SortOrder
    fecha_registro?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    isSet?: boolean
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
    isSet?: boolean
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput | null
    isNot?: UsuarioWhereInput | null
  }

  export type DisponibilidadListRelationFilter = {
    every?: DisponibilidadWhereInput
    some?: DisponibilidadWhereInput
    none?: DisponibilidadWhereInput
  }

  export type DisponibilidadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CuidadorCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    experiencia?: SortOrder
    tipo_servicios?: SortOrder
    calificacion_promedio?: SortOrder
    cantidad_servicios?: SortOrder
  }

  export type CuidadorAvgOrderByAggregateInput = {
    calificacion_promedio?: SortOrder
    cantidad_servicios?: SortOrder
  }

  export type CuidadorMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    experiencia?: SortOrder
    calificacion_promedio?: SortOrder
    cantidad_servicios?: SortOrder
  }

  export type CuidadorMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    experiencia?: SortOrder
    calificacion_promedio?: SortOrder
    cantidad_servicios?: SortOrder
  }

  export type CuidadorSumOrderByAggregateInput = {
    calificacion_promedio?: SortOrder
    cantidad_servicios?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
    isSet?: boolean
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type ServicioCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precio_base?: SortOrder
  }

  export type ServicioAvgOrderByAggregateInput = {
    precio_base?: SortOrder
  }

  export type ServicioMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precio_base?: SortOrder
  }

  export type ServicioMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precio_base?: SortOrder
  }

  export type ServicioSumOrderByAggregateInput = {
    precio_base?: SortOrder
  }

  export type ServicioRelationFilter = {
    is?: ServicioWhereInput | null
    isNot?: ServicioWhereInput | null
  }

  export type DisponibilidadCountOrderByAggregateInput = {
    id?: SortOrder
    cuidador_id?: SortOrder
    fecha_disponible?: SortOrder
    servicio_id?: SortOrder
  }

  export type DisponibilidadMaxOrderByAggregateInput = {
    id?: SortOrder
    cuidador_id?: SortOrder
    fecha_disponible?: SortOrder
    servicio_id?: SortOrder
  }

  export type DisponibilidadMinOrderByAggregateInput = {
    id?: SortOrder
    cuidador_id?: SortOrder
    fecha_disponible?: SortOrder
    servicio_id?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
    isSet?: boolean
  }

  export type ComentarioRelationFilter = {
    is?: ComentarioWhereInput | null
    isNot?: ComentarioWhereInput | null
  }

  export type SolicitudCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    cuidador_id?: SortOrder
    servicio_id?: SortOrder
    fecha_solicitada?: SortOrder
    estado?: SortOrder
    fecha_respuesta?: SortOrder
  }

  export type SolicitudMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    cuidador_id?: SortOrder
    servicio_id?: SortOrder
    fecha_solicitada?: SortOrder
    estado?: SortOrder
    fecha_respuesta?: SortOrder
  }

  export type SolicitudMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    cuidador_id?: SortOrder
    servicio_id?: SortOrder
    fecha_solicitada?: SortOrder
    estado?: SortOrder
    fecha_respuesta?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    isSet?: boolean
  }

  export type SolicitudRelationFilter = {
    is?: SolicitudWhereInput | null
    isNot?: SolicitudWhereInput | null
  }

  export type ComentarioCountOrderByAggregateInput = {
    id?: SortOrder
    solicitud_id?: SortOrder
    usuario_id?: SortOrder
    calificacion?: SortOrder
    comentario?: SortOrder
    fecha?: SortOrder
  }

  export type ComentarioAvgOrderByAggregateInput = {
    calificacion?: SortOrder
  }

  export type ComentarioMaxOrderByAggregateInput = {
    id?: SortOrder
    solicitud_id?: SortOrder
    usuario_id?: SortOrder
    calificacion?: SortOrder
    comentario?: SortOrder
    fecha?: SortOrder
  }

  export type ComentarioMinOrderByAggregateInput = {
    id?: SortOrder
    solicitud_id?: SortOrder
    usuario_id?: SortOrder
    calificacion?: SortOrder
    comentario?: SortOrder
    fecha?: SortOrder
  }

  export type ComentarioSumOrderByAggregateInput = {
    calificacion?: SortOrder
  }

  export type AutenticacionCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    token?: SortOrder
    expiracion?: SortOrder
    tipo?: SortOrder
  }

  export type AutenticacionMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    token?: SortOrder
    expiracion?: SortOrder
    tipo?: SortOrder
  }

  export type AutenticacionMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    token?: SortOrder
    expiracion?: SortOrder
    tipo?: SortOrder
  }

  export type MensajeCountOrderByAggregateInput = {
    id?: SortOrder
    remitente_id?: SortOrder
    destinatario_id?: SortOrder
    contenido?: SortOrder
    fecha?: SortOrder
    solicitud_id?: SortOrder
  }

  export type MensajeMaxOrderByAggregateInput = {
    id?: SortOrder
    remitente_id?: SortOrder
    destinatario_id?: SortOrder
    contenido?: SortOrder
    fecha?: SortOrder
    solicitud_id?: SortOrder
  }

  export type MensajeMinOrderByAggregateInput = {
    id?: SortOrder
    remitente_id?: SortOrder
    destinatario_id?: SortOrder
    contenido?: SortOrder
    fecha?: SortOrder
    solicitud_id?: SortOrder
  }

  export type CuidadorCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<CuidadorCreateWithoutUsuarioInput, CuidadorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: CuidadorCreateOrConnectWithoutUsuarioInput
    connect?: CuidadorWhereUniqueInput
  }

  export type SolicitudCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<SolicitudCreateWithoutUsuarioInput>, Enumerable<SolicitudUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<SolicitudCreateOrConnectWithoutUsuarioInput>
    createMany?: SolicitudCreateManyUsuarioInputEnvelope
    connect?: Enumerable<SolicitudWhereUniqueInput>
  }

  export type ComentarioCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<ComentarioCreateWithoutUsuarioInput>, Enumerable<ComentarioUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<ComentarioCreateOrConnectWithoutUsuarioInput>
    createMany?: ComentarioCreateManyUsuarioInputEnvelope
    connect?: Enumerable<ComentarioWhereUniqueInput>
  }

  export type AutenticacionCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<AutenticacionCreateWithoutUsuarioInput>, Enumerable<AutenticacionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<AutenticacionCreateOrConnectWithoutUsuarioInput>
    createMany?: AutenticacionCreateManyUsuarioInputEnvelope
    connect?: Enumerable<AutenticacionWhereUniqueInput>
  }

  export type MensajeCreateNestedManyWithoutRemitenteInput = {
    create?: XOR<Enumerable<MensajeCreateWithoutRemitenteInput>, Enumerable<MensajeUncheckedCreateWithoutRemitenteInput>>
    connectOrCreate?: Enumerable<MensajeCreateOrConnectWithoutRemitenteInput>
    createMany?: MensajeCreateManyRemitenteInputEnvelope
    connect?: Enumerable<MensajeWhereUniqueInput>
  }

  export type MensajeCreateNestedManyWithoutDestinatarioInput = {
    create?: XOR<Enumerable<MensajeCreateWithoutDestinatarioInput>, Enumerable<MensajeUncheckedCreateWithoutDestinatarioInput>>
    connectOrCreate?: Enumerable<MensajeCreateOrConnectWithoutDestinatarioInput>
    createMany?: MensajeCreateManyDestinatarioInputEnvelope
    connect?: Enumerable<MensajeWhereUniqueInput>
  }

  export type CuidadorUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<CuidadorCreateWithoutUsuarioInput, CuidadorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: CuidadorCreateOrConnectWithoutUsuarioInput
    connect?: CuidadorWhereUniqueInput
  }

  export type SolicitudUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<SolicitudCreateWithoutUsuarioInput>, Enumerable<SolicitudUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<SolicitudCreateOrConnectWithoutUsuarioInput>
    createMany?: SolicitudCreateManyUsuarioInputEnvelope
    connect?: Enumerable<SolicitudWhereUniqueInput>
  }

  export type ComentarioUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<ComentarioCreateWithoutUsuarioInput>, Enumerable<ComentarioUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<ComentarioCreateOrConnectWithoutUsuarioInput>
    createMany?: ComentarioCreateManyUsuarioInputEnvelope
    connect?: Enumerable<ComentarioWhereUniqueInput>
  }

  export type AutenticacionUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<AutenticacionCreateWithoutUsuarioInput>, Enumerable<AutenticacionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<AutenticacionCreateOrConnectWithoutUsuarioInput>
    createMany?: AutenticacionCreateManyUsuarioInputEnvelope
    connect?: Enumerable<AutenticacionWhereUniqueInput>
  }

  export type MensajeUncheckedCreateNestedManyWithoutRemitenteInput = {
    create?: XOR<Enumerable<MensajeCreateWithoutRemitenteInput>, Enumerable<MensajeUncheckedCreateWithoutRemitenteInput>>
    connectOrCreate?: Enumerable<MensajeCreateOrConnectWithoutRemitenteInput>
    createMany?: MensajeCreateManyRemitenteInputEnvelope
    connect?: Enumerable<MensajeWhereUniqueInput>
  }

  export type MensajeUncheckedCreateNestedManyWithoutDestinatarioInput = {
    create?: XOR<Enumerable<MensajeCreateWithoutDestinatarioInput>, Enumerable<MensajeUncheckedCreateWithoutDestinatarioInput>>
    connectOrCreate?: Enumerable<MensajeCreateOrConnectWithoutDestinatarioInput>
    createMany?: MensajeCreateManyDestinatarioInputEnvelope
    connect?: Enumerable<MensajeWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CuidadorUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<CuidadorCreateWithoutUsuarioInput, CuidadorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: CuidadorCreateOrConnectWithoutUsuarioInput
    upsert?: CuidadorUpsertWithoutUsuarioInput
    disconnect?: boolean
    delete?: boolean
    connect?: CuidadorWhereUniqueInput
    update?: XOR<CuidadorUpdateWithoutUsuarioInput, CuidadorUncheckedUpdateWithoutUsuarioInput>
  }

  export type SolicitudUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<SolicitudCreateWithoutUsuarioInput>, Enumerable<SolicitudUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<SolicitudCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<SolicitudUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: SolicitudCreateManyUsuarioInputEnvelope
    set?: Enumerable<SolicitudWhereUniqueInput>
    disconnect?: Enumerable<SolicitudWhereUniqueInput>
    delete?: Enumerable<SolicitudWhereUniqueInput>
    connect?: Enumerable<SolicitudWhereUniqueInput>
    update?: Enumerable<SolicitudUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<SolicitudUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<SolicitudScalarWhereInput>
  }

  export type ComentarioUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<ComentarioCreateWithoutUsuarioInput>, Enumerable<ComentarioUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<ComentarioCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<ComentarioUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: ComentarioCreateManyUsuarioInputEnvelope
    set?: Enumerable<ComentarioWhereUniqueInput>
    disconnect?: Enumerable<ComentarioWhereUniqueInput>
    delete?: Enumerable<ComentarioWhereUniqueInput>
    connect?: Enumerable<ComentarioWhereUniqueInput>
    update?: Enumerable<ComentarioUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<ComentarioUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<ComentarioScalarWhereInput>
  }

  export type AutenticacionUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<AutenticacionCreateWithoutUsuarioInput>, Enumerable<AutenticacionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<AutenticacionCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<AutenticacionUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: AutenticacionCreateManyUsuarioInputEnvelope
    set?: Enumerable<AutenticacionWhereUniqueInput>
    disconnect?: Enumerable<AutenticacionWhereUniqueInput>
    delete?: Enumerable<AutenticacionWhereUniqueInput>
    connect?: Enumerable<AutenticacionWhereUniqueInput>
    update?: Enumerable<AutenticacionUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<AutenticacionUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<AutenticacionScalarWhereInput>
  }

  export type MensajeUpdateManyWithoutRemitenteNestedInput = {
    create?: XOR<Enumerable<MensajeCreateWithoutRemitenteInput>, Enumerable<MensajeUncheckedCreateWithoutRemitenteInput>>
    connectOrCreate?: Enumerable<MensajeCreateOrConnectWithoutRemitenteInput>
    upsert?: Enumerable<MensajeUpsertWithWhereUniqueWithoutRemitenteInput>
    createMany?: MensajeCreateManyRemitenteInputEnvelope
    set?: Enumerable<MensajeWhereUniqueInput>
    disconnect?: Enumerable<MensajeWhereUniqueInput>
    delete?: Enumerable<MensajeWhereUniqueInput>
    connect?: Enumerable<MensajeWhereUniqueInput>
    update?: Enumerable<MensajeUpdateWithWhereUniqueWithoutRemitenteInput>
    updateMany?: Enumerable<MensajeUpdateManyWithWhereWithoutRemitenteInput>
    deleteMany?: Enumerable<MensajeScalarWhereInput>
  }

  export type MensajeUpdateManyWithoutDestinatarioNestedInput = {
    create?: XOR<Enumerable<MensajeCreateWithoutDestinatarioInput>, Enumerable<MensajeUncheckedCreateWithoutDestinatarioInput>>
    connectOrCreate?: Enumerable<MensajeCreateOrConnectWithoutDestinatarioInput>
    upsert?: Enumerable<MensajeUpsertWithWhereUniqueWithoutDestinatarioInput>
    createMany?: MensajeCreateManyDestinatarioInputEnvelope
    set?: Enumerable<MensajeWhereUniqueInput>
    disconnect?: Enumerable<MensajeWhereUniqueInput>
    delete?: Enumerable<MensajeWhereUniqueInput>
    connect?: Enumerable<MensajeWhereUniqueInput>
    update?: Enumerable<MensajeUpdateWithWhereUniqueWithoutDestinatarioInput>
    updateMany?: Enumerable<MensajeUpdateManyWithWhereWithoutDestinatarioInput>
    deleteMany?: Enumerable<MensajeScalarWhereInput>
  }

  export type CuidadorUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<CuidadorCreateWithoutUsuarioInput, CuidadorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: CuidadorCreateOrConnectWithoutUsuarioInput
    upsert?: CuidadorUpsertWithoutUsuarioInput
    disconnect?: boolean
    delete?: boolean
    connect?: CuidadorWhereUniqueInput
    update?: XOR<CuidadorUpdateWithoutUsuarioInput, CuidadorUncheckedUpdateWithoutUsuarioInput>
  }

  export type SolicitudUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<SolicitudCreateWithoutUsuarioInput>, Enumerable<SolicitudUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<SolicitudCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<SolicitudUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: SolicitudCreateManyUsuarioInputEnvelope
    set?: Enumerable<SolicitudWhereUniqueInput>
    disconnect?: Enumerable<SolicitudWhereUniqueInput>
    delete?: Enumerable<SolicitudWhereUniqueInput>
    connect?: Enumerable<SolicitudWhereUniqueInput>
    update?: Enumerable<SolicitudUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<SolicitudUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<SolicitudScalarWhereInput>
  }

  export type ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<ComentarioCreateWithoutUsuarioInput>, Enumerable<ComentarioUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<ComentarioCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<ComentarioUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: ComentarioCreateManyUsuarioInputEnvelope
    set?: Enumerable<ComentarioWhereUniqueInput>
    disconnect?: Enumerable<ComentarioWhereUniqueInput>
    delete?: Enumerable<ComentarioWhereUniqueInput>
    connect?: Enumerable<ComentarioWhereUniqueInput>
    update?: Enumerable<ComentarioUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<ComentarioUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<ComentarioScalarWhereInput>
  }

  export type AutenticacionUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<AutenticacionCreateWithoutUsuarioInput>, Enumerable<AutenticacionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<AutenticacionCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<AutenticacionUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: AutenticacionCreateManyUsuarioInputEnvelope
    set?: Enumerable<AutenticacionWhereUniqueInput>
    disconnect?: Enumerable<AutenticacionWhereUniqueInput>
    delete?: Enumerable<AutenticacionWhereUniqueInput>
    connect?: Enumerable<AutenticacionWhereUniqueInput>
    update?: Enumerable<AutenticacionUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<AutenticacionUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<AutenticacionScalarWhereInput>
  }

  export type MensajeUncheckedUpdateManyWithoutRemitenteNestedInput = {
    create?: XOR<Enumerable<MensajeCreateWithoutRemitenteInput>, Enumerable<MensajeUncheckedCreateWithoutRemitenteInput>>
    connectOrCreate?: Enumerable<MensajeCreateOrConnectWithoutRemitenteInput>
    upsert?: Enumerable<MensajeUpsertWithWhereUniqueWithoutRemitenteInput>
    createMany?: MensajeCreateManyRemitenteInputEnvelope
    set?: Enumerable<MensajeWhereUniqueInput>
    disconnect?: Enumerable<MensajeWhereUniqueInput>
    delete?: Enumerable<MensajeWhereUniqueInput>
    connect?: Enumerable<MensajeWhereUniqueInput>
    update?: Enumerable<MensajeUpdateWithWhereUniqueWithoutRemitenteInput>
    updateMany?: Enumerable<MensajeUpdateManyWithWhereWithoutRemitenteInput>
    deleteMany?: Enumerable<MensajeScalarWhereInput>
  }

  export type MensajeUncheckedUpdateManyWithoutDestinatarioNestedInput = {
    create?: XOR<Enumerable<MensajeCreateWithoutDestinatarioInput>, Enumerable<MensajeUncheckedCreateWithoutDestinatarioInput>>
    connectOrCreate?: Enumerable<MensajeCreateOrConnectWithoutDestinatarioInput>
    upsert?: Enumerable<MensajeUpsertWithWhereUniqueWithoutDestinatarioInput>
    createMany?: MensajeCreateManyDestinatarioInputEnvelope
    set?: Enumerable<MensajeWhereUniqueInput>
    disconnect?: Enumerable<MensajeWhereUniqueInput>
    delete?: Enumerable<MensajeWhereUniqueInput>
    connect?: Enumerable<MensajeWhereUniqueInput>
    update?: Enumerable<MensajeUpdateWithWhereUniqueWithoutDestinatarioInput>
    updateMany?: Enumerable<MensajeUpdateManyWithWhereWithoutDestinatarioInput>
    deleteMany?: Enumerable<MensajeScalarWhereInput>
  }

  export type CuidadorCreatetipo_serviciosInput = {
    set: Enumerable<string>
  }

  export type UsuarioCreateNestedOneWithoutCuidadorInput = {
    create?: XOR<UsuarioCreateWithoutCuidadorInput, UsuarioUncheckedCreateWithoutCuidadorInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutCuidadorInput
    connect?: UsuarioWhereUniqueInput
  }

  export type DisponibilidadCreateNestedManyWithoutCuidadorInput = {
    create?: XOR<Enumerable<DisponibilidadCreateWithoutCuidadorInput>, Enumerable<DisponibilidadUncheckedCreateWithoutCuidadorInput>>
    connectOrCreate?: Enumerable<DisponibilidadCreateOrConnectWithoutCuidadorInput>
    createMany?: DisponibilidadCreateManyCuidadorInputEnvelope
    connect?: Enumerable<DisponibilidadWhereUniqueInput>
  }

  export type SolicitudCreateNestedManyWithoutCuidadorInput = {
    create?: XOR<Enumerable<SolicitudCreateWithoutCuidadorInput>, Enumerable<SolicitudUncheckedCreateWithoutCuidadorInput>>
    connectOrCreate?: Enumerable<SolicitudCreateOrConnectWithoutCuidadorInput>
    createMany?: SolicitudCreateManyCuidadorInputEnvelope
    connect?: Enumerable<SolicitudWhereUniqueInput>
  }

  export type DisponibilidadUncheckedCreateNestedManyWithoutCuidadorInput = {
    create?: XOR<Enumerable<DisponibilidadCreateWithoutCuidadorInput>, Enumerable<DisponibilidadUncheckedCreateWithoutCuidadorInput>>
    connectOrCreate?: Enumerable<DisponibilidadCreateOrConnectWithoutCuidadorInput>
    createMany?: DisponibilidadCreateManyCuidadorInputEnvelope
    connect?: Enumerable<DisponibilidadWhereUniqueInput>
  }

  export type SolicitudUncheckedCreateNestedManyWithoutCuidadorInput = {
    create?: XOR<Enumerable<SolicitudCreateWithoutCuidadorInput>, Enumerable<SolicitudUncheckedCreateWithoutCuidadorInput>>
    connectOrCreate?: Enumerable<SolicitudCreateOrConnectWithoutCuidadorInput>
    createMany?: SolicitudCreateManyCuidadorInputEnvelope
    connect?: Enumerable<SolicitudWhereUniqueInput>
  }

  export type CuidadorUpdatetipo_serviciosInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UsuarioUpdateOneRequiredWithoutCuidadorNestedInput = {
    create?: XOR<UsuarioCreateWithoutCuidadorInput, UsuarioUncheckedCreateWithoutCuidadorInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutCuidadorInput
    upsert?: UsuarioUpsertWithoutCuidadorInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutCuidadorInput, UsuarioUncheckedUpdateWithoutCuidadorInput>
  }

  export type DisponibilidadUpdateManyWithoutCuidadorNestedInput = {
    create?: XOR<Enumerable<DisponibilidadCreateWithoutCuidadorInput>, Enumerable<DisponibilidadUncheckedCreateWithoutCuidadorInput>>
    connectOrCreate?: Enumerable<DisponibilidadCreateOrConnectWithoutCuidadorInput>
    upsert?: Enumerable<DisponibilidadUpsertWithWhereUniqueWithoutCuidadorInput>
    createMany?: DisponibilidadCreateManyCuidadorInputEnvelope
    set?: Enumerable<DisponibilidadWhereUniqueInput>
    disconnect?: Enumerable<DisponibilidadWhereUniqueInput>
    delete?: Enumerable<DisponibilidadWhereUniqueInput>
    connect?: Enumerable<DisponibilidadWhereUniqueInput>
    update?: Enumerable<DisponibilidadUpdateWithWhereUniqueWithoutCuidadorInput>
    updateMany?: Enumerable<DisponibilidadUpdateManyWithWhereWithoutCuidadorInput>
    deleteMany?: Enumerable<DisponibilidadScalarWhereInput>
  }

  export type SolicitudUpdateManyWithoutCuidadorNestedInput = {
    create?: XOR<Enumerable<SolicitudCreateWithoutCuidadorInput>, Enumerable<SolicitudUncheckedCreateWithoutCuidadorInput>>
    connectOrCreate?: Enumerable<SolicitudCreateOrConnectWithoutCuidadorInput>
    upsert?: Enumerable<SolicitudUpsertWithWhereUniqueWithoutCuidadorInput>
    createMany?: SolicitudCreateManyCuidadorInputEnvelope
    set?: Enumerable<SolicitudWhereUniqueInput>
    disconnect?: Enumerable<SolicitudWhereUniqueInput>
    delete?: Enumerable<SolicitudWhereUniqueInput>
    connect?: Enumerable<SolicitudWhereUniqueInput>
    update?: Enumerable<SolicitudUpdateWithWhereUniqueWithoutCuidadorInput>
    updateMany?: Enumerable<SolicitudUpdateManyWithWhereWithoutCuidadorInput>
    deleteMany?: Enumerable<SolicitudScalarWhereInput>
  }

  export type DisponibilidadUncheckedUpdateManyWithoutCuidadorNestedInput = {
    create?: XOR<Enumerable<DisponibilidadCreateWithoutCuidadorInput>, Enumerable<DisponibilidadUncheckedCreateWithoutCuidadorInput>>
    connectOrCreate?: Enumerable<DisponibilidadCreateOrConnectWithoutCuidadorInput>
    upsert?: Enumerable<DisponibilidadUpsertWithWhereUniqueWithoutCuidadorInput>
    createMany?: DisponibilidadCreateManyCuidadorInputEnvelope
    set?: Enumerable<DisponibilidadWhereUniqueInput>
    disconnect?: Enumerable<DisponibilidadWhereUniqueInput>
    delete?: Enumerable<DisponibilidadWhereUniqueInput>
    connect?: Enumerable<DisponibilidadWhereUniqueInput>
    update?: Enumerable<DisponibilidadUpdateWithWhereUniqueWithoutCuidadorInput>
    updateMany?: Enumerable<DisponibilidadUpdateManyWithWhereWithoutCuidadorInput>
    deleteMany?: Enumerable<DisponibilidadScalarWhereInput>
  }

  export type SolicitudUncheckedUpdateManyWithoutCuidadorNestedInput = {
    create?: XOR<Enumerable<SolicitudCreateWithoutCuidadorInput>, Enumerable<SolicitudUncheckedCreateWithoutCuidadorInput>>
    connectOrCreate?: Enumerable<SolicitudCreateOrConnectWithoutCuidadorInput>
    upsert?: Enumerable<SolicitudUpsertWithWhereUniqueWithoutCuidadorInput>
    createMany?: SolicitudCreateManyCuidadorInputEnvelope
    set?: Enumerable<SolicitudWhereUniqueInput>
    disconnect?: Enumerable<SolicitudWhereUniqueInput>
    delete?: Enumerable<SolicitudWhereUniqueInput>
    connect?: Enumerable<SolicitudWhereUniqueInput>
    update?: Enumerable<SolicitudUpdateWithWhereUniqueWithoutCuidadorInput>
    updateMany?: Enumerable<SolicitudUpdateManyWithWhereWithoutCuidadorInput>
    deleteMany?: Enumerable<SolicitudScalarWhereInput>
  }

  export type DisponibilidadCreateNestedManyWithoutServicioInput = {
    create?: XOR<Enumerable<DisponibilidadCreateWithoutServicioInput>, Enumerable<DisponibilidadUncheckedCreateWithoutServicioInput>>
    connectOrCreate?: Enumerable<DisponibilidadCreateOrConnectWithoutServicioInput>
    createMany?: DisponibilidadCreateManyServicioInputEnvelope
    connect?: Enumerable<DisponibilidadWhereUniqueInput>
  }

  export type SolicitudCreateNestedManyWithoutServicioInput = {
    create?: XOR<Enumerable<SolicitudCreateWithoutServicioInput>, Enumerable<SolicitudUncheckedCreateWithoutServicioInput>>
    connectOrCreate?: Enumerable<SolicitudCreateOrConnectWithoutServicioInput>
    createMany?: SolicitudCreateManyServicioInputEnvelope
    connect?: Enumerable<SolicitudWhereUniqueInput>
  }

  export type DisponibilidadUncheckedCreateNestedManyWithoutServicioInput = {
    create?: XOR<Enumerable<DisponibilidadCreateWithoutServicioInput>, Enumerable<DisponibilidadUncheckedCreateWithoutServicioInput>>
    connectOrCreate?: Enumerable<DisponibilidadCreateOrConnectWithoutServicioInput>
    createMany?: DisponibilidadCreateManyServicioInputEnvelope
    connect?: Enumerable<DisponibilidadWhereUniqueInput>
  }

  export type SolicitudUncheckedCreateNestedManyWithoutServicioInput = {
    create?: XOR<Enumerable<SolicitudCreateWithoutServicioInput>, Enumerable<SolicitudUncheckedCreateWithoutServicioInput>>
    connectOrCreate?: Enumerable<SolicitudCreateOrConnectWithoutServicioInput>
    createMany?: SolicitudCreateManyServicioInputEnvelope
    connect?: Enumerable<SolicitudWhereUniqueInput>
  }

  export type DisponibilidadUpdateManyWithoutServicioNestedInput = {
    create?: XOR<Enumerable<DisponibilidadCreateWithoutServicioInput>, Enumerable<DisponibilidadUncheckedCreateWithoutServicioInput>>
    connectOrCreate?: Enumerable<DisponibilidadCreateOrConnectWithoutServicioInput>
    upsert?: Enumerable<DisponibilidadUpsertWithWhereUniqueWithoutServicioInput>
    createMany?: DisponibilidadCreateManyServicioInputEnvelope
    set?: Enumerable<DisponibilidadWhereUniqueInput>
    disconnect?: Enumerable<DisponibilidadWhereUniqueInput>
    delete?: Enumerable<DisponibilidadWhereUniqueInput>
    connect?: Enumerable<DisponibilidadWhereUniqueInput>
    update?: Enumerable<DisponibilidadUpdateWithWhereUniqueWithoutServicioInput>
    updateMany?: Enumerable<DisponibilidadUpdateManyWithWhereWithoutServicioInput>
    deleteMany?: Enumerable<DisponibilidadScalarWhereInput>
  }

  export type SolicitudUpdateManyWithoutServicioNestedInput = {
    create?: XOR<Enumerable<SolicitudCreateWithoutServicioInput>, Enumerable<SolicitudUncheckedCreateWithoutServicioInput>>
    connectOrCreate?: Enumerable<SolicitudCreateOrConnectWithoutServicioInput>
    upsert?: Enumerable<SolicitudUpsertWithWhereUniqueWithoutServicioInput>
    createMany?: SolicitudCreateManyServicioInputEnvelope
    set?: Enumerable<SolicitudWhereUniqueInput>
    disconnect?: Enumerable<SolicitudWhereUniqueInput>
    delete?: Enumerable<SolicitudWhereUniqueInput>
    connect?: Enumerable<SolicitudWhereUniqueInput>
    update?: Enumerable<SolicitudUpdateWithWhereUniqueWithoutServicioInput>
    updateMany?: Enumerable<SolicitudUpdateManyWithWhereWithoutServicioInput>
    deleteMany?: Enumerable<SolicitudScalarWhereInput>
  }

  export type DisponibilidadUncheckedUpdateManyWithoutServicioNestedInput = {
    create?: XOR<Enumerable<DisponibilidadCreateWithoutServicioInput>, Enumerable<DisponibilidadUncheckedCreateWithoutServicioInput>>
    connectOrCreate?: Enumerable<DisponibilidadCreateOrConnectWithoutServicioInput>
    upsert?: Enumerable<DisponibilidadUpsertWithWhereUniqueWithoutServicioInput>
    createMany?: DisponibilidadCreateManyServicioInputEnvelope
    set?: Enumerable<DisponibilidadWhereUniqueInput>
    disconnect?: Enumerable<DisponibilidadWhereUniqueInput>
    delete?: Enumerable<DisponibilidadWhereUniqueInput>
    connect?: Enumerable<DisponibilidadWhereUniqueInput>
    update?: Enumerable<DisponibilidadUpdateWithWhereUniqueWithoutServicioInput>
    updateMany?: Enumerable<DisponibilidadUpdateManyWithWhereWithoutServicioInput>
    deleteMany?: Enumerable<DisponibilidadScalarWhereInput>
  }

  export type SolicitudUncheckedUpdateManyWithoutServicioNestedInput = {
    create?: XOR<Enumerable<SolicitudCreateWithoutServicioInput>, Enumerable<SolicitudUncheckedCreateWithoutServicioInput>>
    connectOrCreate?: Enumerable<SolicitudCreateOrConnectWithoutServicioInput>
    upsert?: Enumerable<SolicitudUpsertWithWhereUniqueWithoutServicioInput>
    createMany?: SolicitudCreateManyServicioInputEnvelope
    set?: Enumerable<SolicitudWhereUniqueInput>
    disconnect?: Enumerable<SolicitudWhereUniqueInput>
    delete?: Enumerable<SolicitudWhereUniqueInput>
    connect?: Enumerable<SolicitudWhereUniqueInput>
    update?: Enumerable<SolicitudUpdateWithWhereUniqueWithoutServicioInput>
    updateMany?: Enumerable<SolicitudUpdateManyWithWhereWithoutServicioInput>
    deleteMany?: Enumerable<SolicitudScalarWhereInput>
  }

  export type CuidadorCreateNestedOneWithoutDisponibilidadesInput = {
    create?: XOR<CuidadorCreateWithoutDisponibilidadesInput, CuidadorUncheckedCreateWithoutDisponibilidadesInput>
    connectOrCreate?: CuidadorCreateOrConnectWithoutDisponibilidadesInput
    connect?: CuidadorWhereUniqueInput
  }

  export type ServicioCreateNestedOneWithoutDisponibilidadesInput = {
    create?: XOR<ServicioCreateWithoutDisponibilidadesInput, ServicioUncheckedCreateWithoutDisponibilidadesInput>
    connectOrCreate?: ServicioCreateOrConnectWithoutDisponibilidadesInput
    connect?: ServicioWhereUniqueInput
  }

  export type CuidadorUpdateOneRequiredWithoutDisponibilidadesNestedInput = {
    create?: XOR<CuidadorCreateWithoutDisponibilidadesInput, CuidadorUncheckedCreateWithoutDisponibilidadesInput>
    connectOrCreate?: CuidadorCreateOrConnectWithoutDisponibilidadesInput
    upsert?: CuidadorUpsertWithoutDisponibilidadesInput
    connect?: CuidadorWhereUniqueInput
    update?: XOR<CuidadorUpdateWithoutDisponibilidadesInput, CuidadorUncheckedUpdateWithoutDisponibilidadesInput>
  }

  export type ServicioUpdateOneRequiredWithoutDisponibilidadesNestedInput = {
    create?: XOR<ServicioCreateWithoutDisponibilidadesInput, ServicioUncheckedCreateWithoutDisponibilidadesInput>
    connectOrCreate?: ServicioCreateOrConnectWithoutDisponibilidadesInput
    upsert?: ServicioUpsertWithoutDisponibilidadesInput
    connect?: ServicioWhereUniqueInput
    update?: XOR<ServicioUpdateWithoutDisponibilidadesInput, ServicioUncheckedUpdateWithoutDisponibilidadesInput>
  }

  export type UsuarioCreateNestedOneWithoutSolicitudesInput = {
    create?: XOR<UsuarioCreateWithoutSolicitudesInput, UsuarioUncheckedCreateWithoutSolicitudesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutSolicitudesInput
    connect?: UsuarioWhereUniqueInput
  }

  export type CuidadorCreateNestedOneWithoutSolicitudesInput = {
    create?: XOR<CuidadorCreateWithoutSolicitudesInput, CuidadorUncheckedCreateWithoutSolicitudesInput>
    connectOrCreate?: CuidadorCreateOrConnectWithoutSolicitudesInput
    connect?: CuidadorWhereUniqueInput
  }

  export type ServicioCreateNestedOneWithoutSolicitudesInput = {
    create?: XOR<ServicioCreateWithoutSolicitudesInput, ServicioUncheckedCreateWithoutSolicitudesInput>
    connectOrCreate?: ServicioCreateOrConnectWithoutSolicitudesInput
    connect?: ServicioWhereUniqueInput
  }

  export type ComentarioCreateNestedOneWithoutSolicitudInput = {
    create?: XOR<ComentarioCreateWithoutSolicitudInput, ComentarioUncheckedCreateWithoutSolicitudInput>
    connectOrCreate?: ComentarioCreateOrConnectWithoutSolicitudInput
    connect?: ComentarioWhereUniqueInput
  }

  export type MensajeCreateNestedManyWithoutSolicitudInput = {
    create?: XOR<Enumerable<MensajeCreateWithoutSolicitudInput>, Enumerable<MensajeUncheckedCreateWithoutSolicitudInput>>
    connectOrCreate?: Enumerable<MensajeCreateOrConnectWithoutSolicitudInput>
    createMany?: MensajeCreateManySolicitudInputEnvelope
    connect?: Enumerable<MensajeWhereUniqueInput>
  }

  export type ComentarioUncheckedCreateNestedOneWithoutSolicitudInput = {
    create?: XOR<ComentarioCreateWithoutSolicitudInput, ComentarioUncheckedCreateWithoutSolicitudInput>
    connectOrCreate?: ComentarioCreateOrConnectWithoutSolicitudInput
    connect?: ComentarioWhereUniqueInput
  }

  export type MensajeUncheckedCreateNestedManyWithoutSolicitudInput = {
    create?: XOR<Enumerable<MensajeCreateWithoutSolicitudInput>, Enumerable<MensajeUncheckedCreateWithoutSolicitudInput>>
    connectOrCreate?: Enumerable<MensajeCreateOrConnectWithoutSolicitudInput>
    createMany?: MensajeCreateManySolicitudInputEnvelope
    connect?: Enumerable<MensajeWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type UsuarioUpdateOneRequiredWithoutSolicitudesNestedInput = {
    create?: XOR<UsuarioCreateWithoutSolicitudesInput, UsuarioUncheckedCreateWithoutSolicitudesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutSolicitudesInput
    upsert?: UsuarioUpsertWithoutSolicitudesInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutSolicitudesInput, UsuarioUncheckedUpdateWithoutSolicitudesInput>
  }

  export type CuidadorUpdateOneRequiredWithoutSolicitudesNestedInput = {
    create?: XOR<CuidadorCreateWithoutSolicitudesInput, CuidadorUncheckedCreateWithoutSolicitudesInput>
    connectOrCreate?: CuidadorCreateOrConnectWithoutSolicitudesInput
    upsert?: CuidadorUpsertWithoutSolicitudesInput
    connect?: CuidadorWhereUniqueInput
    update?: XOR<CuidadorUpdateWithoutSolicitudesInput, CuidadorUncheckedUpdateWithoutSolicitudesInput>
  }

  export type ServicioUpdateOneRequiredWithoutSolicitudesNestedInput = {
    create?: XOR<ServicioCreateWithoutSolicitudesInput, ServicioUncheckedCreateWithoutSolicitudesInput>
    connectOrCreate?: ServicioCreateOrConnectWithoutSolicitudesInput
    upsert?: ServicioUpsertWithoutSolicitudesInput
    connect?: ServicioWhereUniqueInput
    update?: XOR<ServicioUpdateWithoutSolicitudesInput, ServicioUncheckedUpdateWithoutSolicitudesInput>
  }

  export type ComentarioUpdateOneWithoutSolicitudNestedInput = {
    create?: XOR<ComentarioCreateWithoutSolicitudInput, ComentarioUncheckedCreateWithoutSolicitudInput>
    connectOrCreate?: ComentarioCreateOrConnectWithoutSolicitudInput
    upsert?: ComentarioUpsertWithoutSolicitudInput
    disconnect?: boolean
    delete?: boolean
    connect?: ComentarioWhereUniqueInput
    update?: XOR<ComentarioUpdateWithoutSolicitudInput, ComentarioUncheckedUpdateWithoutSolicitudInput>
  }

  export type MensajeUpdateManyWithoutSolicitudNestedInput = {
    create?: XOR<Enumerable<MensajeCreateWithoutSolicitudInput>, Enumerable<MensajeUncheckedCreateWithoutSolicitudInput>>
    connectOrCreate?: Enumerable<MensajeCreateOrConnectWithoutSolicitudInput>
    upsert?: Enumerable<MensajeUpsertWithWhereUniqueWithoutSolicitudInput>
    createMany?: MensajeCreateManySolicitudInputEnvelope
    set?: Enumerable<MensajeWhereUniqueInput>
    disconnect?: Enumerable<MensajeWhereUniqueInput>
    delete?: Enumerable<MensajeWhereUniqueInput>
    connect?: Enumerable<MensajeWhereUniqueInput>
    update?: Enumerable<MensajeUpdateWithWhereUniqueWithoutSolicitudInput>
    updateMany?: Enumerable<MensajeUpdateManyWithWhereWithoutSolicitudInput>
    deleteMany?: Enumerable<MensajeScalarWhereInput>
  }

  export type ComentarioUncheckedUpdateOneWithoutSolicitudNestedInput = {
    create?: XOR<ComentarioCreateWithoutSolicitudInput, ComentarioUncheckedCreateWithoutSolicitudInput>
    connectOrCreate?: ComentarioCreateOrConnectWithoutSolicitudInput
    upsert?: ComentarioUpsertWithoutSolicitudInput
    disconnect?: boolean
    delete?: boolean
    connect?: ComentarioWhereUniqueInput
    update?: XOR<ComentarioUpdateWithoutSolicitudInput, ComentarioUncheckedUpdateWithoutSolicitudInput>
  }

  export type MensajeUncheckedUpdateManyWithoutSolicitudNestedInput = {
    create?: XOR<Enumerable<MensajeCreateWithoutSolicitudInput>, Enumerable<MensajeUncheckedCreateWithoutSolicitudInput>>
    connectOrCreate?: Enumerable<MensajeCreateOrConnectWithoutSolicitudInput>
    upsert?: Enumerable<MensajeUpsertWithWhereUniqueWithoutSolicitudInput>
    createMany?: MensajeCreateManySolicitudInputEnvelope
    set?: Enumerable<MensajeWhereUniqueInput>
    disconnect?: Enumerable<MensajeWhereUniqueInput>
    delete?: Enumerable<MensajeWhereUniqueInput>
    connect?: Enumerable<MensajeWhereUniqueInput>
    update?: Enumerable<MensajeUpdateWithWhereUniqueWithoutSolicitudInput>
    updateMany?: Enumerable<MensajeUpdateManyWithWhereWithoutSolicitudInput>
    deleteMany?: Enumerable<MensajeScalarWhereInput>
  }

  export type SolicitudCreateNestedOneWithoutComentarioInput = {
    create?: XOR<SolicitudCreateWithoutComentarioInput, SolicitudUncheckedCreateWithoutComentarioInput>
    connectOrCreate?: SolicitudCreateOrConnectWithoutComentarioInput
    connect?: SolicitudWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutComentariosInput = {
    create?: XOR<UsuarioCreateWithoutComentariosInput, UsuarioUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutComentariosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type SolicitudUpdateOneRequiredWithoutComentarioNestedInput = {
    create?: XOR<SolicitudCreateWithoutComentarioInput, SolicitudUncheckedCreateWithoutComentarioInput>
    connectOrCreate?: SolicitudCreateOrConnectWithoutComentarioInput
    upsert?: SolicitudUpsertWithoutComentarioInput
    connect?: SolicitudWhereUniqueInput
    update?: XOR<SolicitudUpdateWithoutComentarioInput, SolicitudUncheckedUpdateWithoutComentarioInput>
  }

  export type UsuarioUpdateOneRequiredWithoutComentariosNestedInput = {
    create?: XOR<UsuarioCreateWithoutComentariosInput, UsuarioUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutComentariosInput
    upsert?: UsuarioUpsertWithoutComentariosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutComentariosInput, UsuarioUncheckedUpdateWithoutComentariosInput>
  }

  export type UsuarioCreateNestedOneWithoutAutenticacionInput = {
    create?: XOR<UsuarioCreateWithoutAutenticacionInput, UsuarioUncheckedCreateWithoutAutenticacionInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutAutenticacionInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutAutenticacionNestedInput = {
    create?: XOR<UsuarioCreateWithoutAutenticacionInput, UsuarioUncheckedCreateWithoutAutenticacionInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutAutenticacionInput
    upsert?: UsuarioUpsertWithoutAutenticacionInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutAutenticacionInput, UsuarioUncheckedUpdateWithoutAutenticacionInput>
  }

  export type UsuarioCreateNestedOneWithoutMensajes_enviadosInput = {
    create?: XOR<UsuarioCreateWithoutMensajes_enviadosInput, UsuarioUncheckedCreateWithoutMensajes_enviadosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutMensajes_enviadosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutMensajes_recibidosInput = {
    create?: XOR<UsuarioCreateWithoutMensajes_recibidosInput, UsuarioUncheckedCreateWithoutMensajes_recibidosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutMensajes_recibidosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type SolicitudCreateNestedOneWithoutMensajesInput = {
    create?: XOR<SolicitudCreateWithoutMensajesInput, SolicitudUncheckedCreateWithoutMensajesInput>
    connectOrCreate?: SolicitudCreateOrConnectWithoutMensajesInput
    connect?: SolicitudWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutMensajes_enviadosNestedInput = {
    create?: XOR<UsuarioCreateWithoutMensajes_enviadosInput, UsuarioUncheckedCreateWithoutMensajes_enviadosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutMensajes_enviadosInput
    upsert?: UsuarioUpsertWithoutMensajes_enviadosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutMensajes_enviadosInput, UsuarioUncheckedUpdateWithoutMensajes_enviadosInput>
  }

  export type UsuarioUpdateOneRequiredWithoutMensajes_recibidosNestedInput = {
    create?: XOR<UsuarioCreateWithoutMensajes_recibidosInput, UsuarioUncheckedCreateWithoutMensajes_recibidosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutMensajes_recibidosInput
    upsert?: UsuarioUpsertWithoutMensajes_recibidosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutMensajes_recibidosInput, UsuarioUncheckedUpdateWithoutMensajes_recibidosInput>
  }

  export type SolicitudUpdateOneWithoutMensajesNestedInput = {
    create?: XOR<SolicitudCreateWithoutMensajesInput, SolicitudUncheckedCreateWithoutMensajesInput>
    connectOrCreate?: SolicitudCreateOrConnectWithoutMensajesInput
    upsert?: SolicitudUpsertWithoutMensajesInput
    disconnect?: boolean
    delete?: boolean
    connect?: SolicitudWhereUniqueInput
    update?: XOR<SolicitudUpdateWithoutMensajesInput, SolicitudUncheckedUpdateWithoutMensajesInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
    isSet?: boolean
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    isSet?: boolean
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
    isSet?: boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
    isSet?: boolean
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
    isSet?: boolean
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    isSet?: boolean
  }

  export type CuidadorCreateWithoutUsuarioInput = {
    id?: string
    experiencia?: string | null
    tipo_servicios?: CuidadorCreatetipo_serviciosInput | Enumerable<string>
    calificacion_promedio?: number | null
    cantidad_servicios?: number
    disponibilidades?: DisponibilidadCreateNestedManyWithoutCuidadorInput
    solicitudes?: SolicitudCreateNestedManyWithoutCuidadorInput
  }

  export type CuidadorUncheckedCreateWithoutUsuarioInput = {
    id?: string
    experiencia?: string | null
    tipo_servicios?: CuidadorCreatetipo_serviciosInput | Enumerable<string>
    calificacion_promedio?: number | null
    cantidad_servicios?: number
    disponibilidades?: DisponibilidadUncheckedCreateNestedManyWithoutCuidadorInput
    solicitudes?: SolicitudUncheckedCreateNestedManyWithoutCuidadorInput
  }

  export type CuidadorCreateOrConnectWithoutUsuarioInput = {
    where: CuidadorWhereUniqueInput
    create: XOR<CuidadorCreateWithoutUsuarioInput, CuidadorUncheckedCreateWithoutUsuarioInput>
  }

  export type SolicitudCreateWithoutUsuarioInput = {
    id?: string
    fecha_solicitada?: Date | string
    estado: string
    fecha_respuesta?: Date | string | null
    cuidador: CuidadorCreateNestedOneWithoutSolicitudesInput
    servicio: ServicioCreateNestedOneWithoutSolicitudesInput
    comentario?: ComentarioCreateNestedOneWithoutSolicitudInput
    mensajes?: MensajeCreateNestedManyWithoutSolicitudInput
  }

  export type SolicitudUncheckedCreateWithoutUsuarioInput = {
    id?: string
    cuidador_id: string
    servicio_id: string
    fecha_solicitada?: Date | string
    estado: string
    fecha_respuesta?: Date | string | null
    comentario?: ComentarioUncheckedCreateNestedOneWithoutSolicitudInput
    mensajes?: MensajeUncheckedCreateNestedManyWithoutSolicitudInput
  }

  export type SolicitudCreateOrConnectWithoutUsuarioInput = {
    where: SolicitudWhereUniqueInput
    create: XOR<SolicitudCreateWithoutUsuarioInput, SolicitudUncheckedCreateWithoutUsuarioInput>
  }

  export type SolicitudCreateManyUsuarioInputEnvelope = {
    data: Enumerable<SolicitudCreateManyUsuarioInput>
  }

  export type ComentarioCreateWithoutUsuarioInput = {
    id?: string
    calificacion: number
    comentario?: string | null
    fecha?: Date | string
    solicitud: SolicitudCreateNestedOneWithoutComentarioInput
  }

  export type ComentarioUncheckedCreateWithoutUsuarioInput = {
    id?: string
    solicitud_id: string
    calificacion: number
    comentario?: string | null
    fecha?: Date | string
  }

  export type ComentarioCreateOrConnectWithoutUsuarioInput = {
    where: ComentarioWhereUniqueInput
    create: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput>
  }

  export type ComentarioCreateManyUsuarioInputEnvelope = {
    data: Enumerable<ComentarioCreateManyUsuarioInput>
  }

  export type AutenticacionCreateWithoutUsuarioInput = {
    id?: string
    token: string
    expiracion: Date | string
    tipo: string
  }

  export type AutenticacionUncheckedCreateWithoutUsuarioInput = {
    id?: string
    token: string
    expiracion: Date | string
    tipo: string
  }

  export type AutenticacionCreateOrConnectWithoutUsuarioInput = {
    where: AutenticacionWhereUniqueInput
    create: XOR<AutenticacionCreateWithoutUsuarioInput, AutenticacionUncheckedCreateWithoutUsuarioInput>
  }

  export type AutenticacionCreateManyUsuarioInputEnvelope = {
    data: Enumerable<AutenticacionCreateManyUsuarioInput>
  }

  export type MensajeCreateWithoutRemitenteInput = {
    id?: string
    contenido: string
    fecha?: Date | string
    destinatario: UsuarioCreateNestedOneWithoutMensajes_recibidosInput
    solicitud?: SolicitudCreateNestedOneWithoutMensajesInput
  }

  export type MensajeUncheckedCreateWithoutRemitenteInput = {
    id?: string
    destinatario_id: string
    contenido: string
    fecha?: Date | string
    solicitud_id?: string | null
  }

  export type MensajeCreateOrConnectWithoutRemitenteInput = {
    where: MensajeWhereUniqueInput
    create: XOR<MensajeCreateWithoutRemitenteInput, MensajeUncheckedCreateWithoutRemitenteInput>
  }

  export type MensajeCreateManyRemitenteInputEnvelope = {
    data: Enumerable<MensajeCreateManyRemitenteInput>
  }

  export type MensajeCreateWithoutDestinatarioInput = {
    id?: string
    contenido: string
    fecha?: Date | string
    remitente: UsuarioCreateNestedOneWithoutMensajes_enviadosInput
    solicitud?: SolicitudCreateNestedOneWithoutMensajesInput
  }

  export type MensajeUncheckedCreateWithoutDestinatarioInput = {
    id?: string
    remitente_id: string
    contenido: string
    fecha?: Date | string
    solicitud_id?: string | null
  }

  export type MensajeCreateOrConnectWithoutDestinatarioInput = {
    where: MensajeWhereUniqueInput
    create: XOR<MensajeCreateWithoutDestinatarioInput, MensajeUncheckedCreateWithoutDestinatarioInput>
  }

  export type MensajeCreateManyDestinatarioInputEnvelope = {
    data: Enumerable<MensajeCreateManyDestinatarioInput>
  }

  export type CuidadorUpsertWithoutUsuarioInput = {
    update: XOR<CuidadorUpdateWithoutUsuarioInput, CuidadorUncheckedUpdateWithoutUsuarioInput>
    create: XOR<CuidadorCreateWithoutUsuarioInput, CuidadorUncheckedCreateWithoutUsuarioInput>
  }

  export type CuidadorUpdateWithoutUsuarioInput = {
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_servicios?: CuidadorUpdatetipo_serviciosInput | Enumerable<string>
    calificacion_promedio?: NullableFloatFieldUpdateOperationsInput | number | null
    cantidad_servicios?: IntFieldUpdateOperationsInput | number
    disponibilidades?: DisponibilidadUpdateManyWithoutCuidadorNestedInput
    solicitudes?: SolicitudUpdateManyWithoutCuidadorNestedInput
  }

  export type CuidadorUncheckedUpdateWithoutUsuarioInput = {
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_servicios?: CuidadorUpdatetipo_serviciosInput | Enumerable<string>
    calificacion_promedio?: NullableFloatFieldUpdateOperationsInput | number | null
    cantidad_servicios?: IntFieldUpdateOperationsInput | number
    disponibilidades?: DisponibilidadUncheckedUpdateManyWithoutCuidadorNestedInput
    solicitudes?: SolicitudUncheckedUpdateManyWithoutCuidadorNestedInput
  }

  export type SolicitudUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: SolicitudWhereUniqueInput
    update: XOR<SolicitudUpdateWithoutUsuarioInput, SolicitudUncheckedUpdateWithoutUsuarioInput>
    create: XOR<SolicitudCreateWithoutUsuarioInput, SolicitudUncheckedCreateWithoutUsuarioInput>
  }

  export type SolicitudUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: SolicitudWhereUniqueInput
    data: XOR<SolicitudUpdateWithoutUsuarioInput, SolicitudUncheckedUpdateWithoutUsuarioInput>
  }

  export type SolicitudUpdateManyWithWhereWithoutUsuarioInput = {
    where: SolicitudScalarWhereInput
    data: XOR<SolicitudUpdateManyMutationInput, SolicitudUncheckedUpdateManyWithoutSolicitudesInput>
  }

  export type SolicitudScalarWhereInput = {
    AND?: Enumerable<SolicitudScalarWhereInput>
    OR?: Enumerable<SolicitudScalarWhereInput>
    NOT?: Enumerable<SolicitudScalarWhereInput>
    id?: StringFilter | string
    usuario_id?: StringFilter | string
    cuidador_id?: StringFilter | string
    servicio_id?: StringFilter | string
    fecha_solicitada?: DateTimeFilter | Date | string
    estado?: StringFilter | string
    fecha_respuesta?: DateTimeNullableFilter | Date | string | null
  }

  export type ComentarioUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ComentarioWhereUniqueInput
    update: XOR<ComentarioUpdateWithoutUsuarioInput, ComentarioUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput>
  }

  export type ComentarioUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ComentarioWhereUniqueInput
    data: XOR<ComentarioUpdateWithoutUsuarioInput, ComentarioUncheckedUpdateWithoutUsuarioInput>
  }

  export type ComentarioUpdateManyWithWhereWithoutUsuarioInput = {
    where: ComentarioScalarWhereInput
    data: XOR<ComentarioUpdateManyMutationInput, ComentarioUncheckedUpdateManyWithoutComentariosInput>
  }

  export type ComentarioScalarWhereInput = {
    AND?: Enumerable<ComentarioScalarWhereInput>
    OR?: Enumerable<ComentarioScalarWhereInput>
    NOT?: Enumerable<ComentarioScalarWhereInput>
    id?: StringFilter | string
    solicitud_id?: StringFilter | string
    usuario_id?: StringFilter | string
    calificacion?: IntFilter | number
    comentario?: StringNullableFilter | string | null
    fecha?: DateTimeFilter | Date | string
  }

  export type AutenticacionUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: AutenticacionWhereUniqueInput
    update: XOR<AutenticacionUpdateWithoutUsuarioInput, AutenticacionUncheckedUpdateWithoutUsuarioInput>
    create: XOR<AutenticacionCreateWithoutUsuarioInput, AutenticacionUncheckedCreateWithoutUsuarioInput>
  }

  export type AutenticacionUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: AutenticacionWhereUniqueInput
    data: XOR<AutenticacionUpdateWithoutUsuarioInput, AutenticacionUncheckedUpdateWithoutUsuarioInput>
  }

  export type AutenticacionUpdateManyWithWhereWithoutUsuarioInput = {
    where: AutenticacionScalarWhereInput
    data: XOR<AutenticacionUpdateManyMutationInput, AutenticacionUncheckedUpdateManyWithoutAutenticacionInput>
  }

  export type AutenticacionScalarWhereInput = {
    AND?: Enumerable<AutenticacionScalarWhereInput>
    OR?: Enumerable<AutenticacionScalarWhereInput>
    NOT?: Enumerable<AutenticacionScalarWhereInput>
    id?: StringFilter | string
    usuario_id?: StringFilter | string
    token?: StringFilter | string
    expiracion?: DateTimeFilter | Date | string
    tipo?: StringFilter | string
  }

  export type MensajeUpsertWithWhereUniqueWithoutRemitenteInput = {
    where: MensajeWhereUniqueInput
    update: XOR<MensajeUpdateWithoutRemitenteInput, MensajeUncheckedUpdateWithoutRemitenteInput>
    create: XOR<MensajeCreateWithoutRemitenteInput, MensajeUncheckedCreateWithoutRemitenteInput>
  }

  export type MensajeUpdateWithWhereUniqueWithoutRemitenteInput = {
    where: MensajeWhereUniqueInput
    data: XOR<MensajeUpdateWithoutRemitenteInput, MensajeUncheckedUpdateWithoutRemitenteInput>
  }

  export type MensajeUpdateManyWithWhereWithoutRemitenteInput = {
    where: MensajeScalarWhereInput
    data: XOR<MensajeUpdateManyMutationInput, MensajeUncheckedUpdateManyWithoutMensajes_enviadosInput>
  }

  export type MensajeScalarWhereInput = {
    AND?: Enumerable<MensajeScalarWhereInput>
    OR?: Enumerable<MensajeScalarWhereInput>
    NOT?: Enumerable<MensajeScalarWhereInput>
    id?: StringFilter | string
    remitente_id?: StringFilter | string
    destinatario_id?: StringFilter | string
    contenido?: StringFilter | string
    fecha?: DateTimeFilter | Date | string
    solicitud_id?: StringNullableFilter | string | null
  }

  export type MensajeUpsertWithWhereUniqueWithoutDestinatarioInput = {
    where: MensajeWhereUniqueInput
    update: XOR<MensajeUpdateWithoutDestinatarioInput, MensajeUncheckedUpdateWithoutDestinatarioInput>
    create: XOR<MensajeCreateWithoutDestinatarioInput, MensajeUncheckedCreateWithoutDestinatarioInput>
  }

  export type MensajeUpdateWithWhereUniqueWithoutDestinatarioInput = {
    where: MensajeWhereUniqueInput
    data: XOR<MensajeUpdateWithoutDestinatarioInput, MensajeUncheckedUpdateWithoutDestinatarioInput>
  }

  export type MensajeUpdateManyWithWhereWithoutDestinatarioInput = {
    where: MensajeScalarWhereInput
    data: XOR<MensajeUpdateManyMutationInput, MensajeUncheckedUpdateManyWithoutMensajes_recibidosInput>
  }

  export type UsuarioCreateWithoutCuidadorInput = {
    id?: string
    nombre: string
    correo_electronico: string
    contrasena: string
    telefono?: string | null
    direccion?: string | null
    es_cuidador?: boolean
    fecha_registro?: Date | string
    solicitudes?: SolicitudCreateNestedManyWithoutUsuarioInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    autenticacion?: AutenticacionCreateNestedManyWithoutUsuarioInput
    mensajes_enviados?: MensajeCreateNestedManyWithoutRemitenteInput
    mensajes_recibidos?: MensajeCreateNestedManyWithoutDestinatarioInput
  }

  export type UsuarioUncheckedCreateWithoutCuidadorInput = {
    id?: string
    nombre: string
    correo_electronico: string
    contrasena: string
    telefono?: string | null
    direccion?: string | null
    es_cuidador?: boolean
    fecha_registro?: Date | string
    solicitudes?: SolicitudUncheckedCreateNestedManyWithoutUsuarioInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    autenticacion?: AutenticacionUncheckedCreateNestedManyWithoutUsuarioInput
    mensajes_enviados?: MensajeUncheckedCreateNestedManyWithoutRemitenteInput
    mensajes_recibidos?: MensajeUncheckedCreateNestedManyWithoutDestinatarioInput
  }

  export type UsuarioCreateOrConnectWithoutCuidadorInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutCuidadorInput, UsuarioUncheckedCreateWithoutCuidadorInput>
  }

  export type DisponibilidadCreateWithoutCuidadorInput = {
    id?: string
    fecha_disponible: Date | string
    servicio: ServicioCreateNestedOneWithoutDisponibilidadesInput
  }

  export type DisponibilidadUncheckedCreateWithoutCuidadorInput = {
    id?: string
    fecha_disponible: Date | string
    servicio_id: string
  }

  export type DisponibilidadCreateOrConnectWithoutCuidadorInput = {
    where: DisponibilidadWhereUniqueInput
    create: XOR<DisponibilidadCreateWithoutCuidadorInput, DisponibilidadUncheckedCreateWithoutCuidadorInput>
  }

  export type DisponibilidadCreateManyCuidadorInputEnvelope = {
    data: Enumerable<DisponibilidadCreateManyCuidadorInput>
  }

  export type SolicitudCreateWithoutCuidadorInput = {
    id?: string
    fecha_solicitada?: Date | string
    estado: string
    fecha_respuesta?: Date | string | null
    usuario: UsuarioCreateNestedOneWithoutSolicitudesInput
    servicio: ServicioCreateNestedOneWithoutSolicitudesInput
    comentario?: ComentarioCreateNestedOneWithoutSolicitudInput
    mensajes?: MensajeCreateNestedManyWithoutSolicitudInput
  }

  export type SolicitudUncheckedCreateWithoutCuidadorInput = {
    id?: string
    usuario_id: string
    servicio_id: string
    fecha_solicitada?: Date | string
    estado: string
    fecha_respuesta?: Date | string | null
    comentario?: ComentarioUncheckedCreateNestedOneWithoutSolicitudInput
    mensajes?: MensajeUncheckedCreateNestedManyWithoutSolicitudInput
  }

  export type SolicitudCreateOrConnectWithoutCuidadorInput = {
    where: SolicitudWhereUniqueInput
    create: XOR<SolicitudCreateWithoutCuidadorInput, SolicitudUncheckedCreateWithoutCuidadorInput>
  }

  export type SolicitudCreateManyCuidadorInputEnvelope = {
    data: Enumerable<SolicitudCreateManyCuidadorInput>
  }

  export type UsuarioUpsertWithoutCuidadorInput = {
    update: XOR<UsuarioUpdateWithoutCuidadorInput, UsuarioUncheckedUpdateWithoutCuidadorInput>
    create: XOR<UsuarioCreateWithoutCuidadorInput, UsuarioUncheckedCreateWithoutCuidadorInput>
  }

  export type UsuarioUpdateWithoutCuidadorInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    es_cuidador?: BoolFieldUpdateOperationsInput | boolean
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    solicitudes?: SolicitudUpdateManyWithoutUsuarioNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    autenticacion?: AutenticacionUpdateManyWithoutUsuarioNestedInput
    mensajes_enviados?: MensajeUpdateManyWithoutRemitenteNestedInput
    mensajes_recibidos?: MensajeUpdateManyWithoutDestinatarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutCuidadorInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    es_cuidador?: BoolFieldUpdateOperationsInput | boolean
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    solicitudes?: SolicitudUncheckedUpdateManyWithoutUsuarioNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    autenticacion?: AutenticacionUncheckedUpdateManyWithoutUsuarioNestedInput
    mensajes_enviados?: MensajeUncheckedUpdateManyWithoutRemitenteNestedInput
    mensajes_recibidos?: MensajeUncheckedUpdateManyWithoutDestinatarioNestedInput
  }

  export type DisponibilidadUpsertWithWhereUniqueWithoutCuidadorInput = {
    where: DisponibilidadWhereUniqueInput
    update: XOR<DisponibilidadUpdateWithoutCuidadorInput, DisponibilidadUncheckedUpdateWithoutCuidadorInput>
    create: XOR<DisponibilidadCreateWithoutCuidadorInput, DisponibilidadUncheckedCreateWithoutCuidadorInput>
  }

  export type DisponibilidadUpdateWithWhereUniqueWithoutCuidadorInput = {
    where: DisponibilidadWhereUniqueInput
    data: XOR<DisponibilidadUpdateWithoutCuidadorInput, DisponibilidadUncheckedUpdateWithoutCuidadorInput>
  }

  export type DisponibilidadUpdateManyWithWhereWithoutCuidadorInput = {
    where: DisponibilidadScalarWhereInput
    data: XOR<DisponibilidadUpdateManyMutationInput, DisponibilidadUncheckedUpdateManyWithoutDisponibilidadesInput>
  }

  export type DisponibilidadScalarWhereInput = {
    AND?: Enumerable<DisponibilidadScalarWhereInput>
    OR?: Enumerable<DisponibilidadScalarWhereInput>
    NOT?: Enumerable<DisponibilidadScalarWhereInput>
    id?: StringFilter | string
    cuidador_id?: StringFilter | string
    fecha_disponible?: DateTimeFilter | Date | string
    servicio_id?: StringFilter | string
  }

  export type SolicitudUpsertWithWhereUniqueWithoutCuidadorInput = {
    where: SolicitudWhereUniqueInput
    update: XOR<SolicitudUpdateWithoutCuidadorInput, SolicitudUncheckedUpdateWithoutCuidadorInput>
    create: XOR<SolicitudCreateWithoutCuidadorInput, SolicitudUncheckedCreateWithoutCuidadorInput>
  }

  export type SolicitudUpdateWithWhereUniqueWithoutCuidadorInput = {
    where: SolicitudWhereUniqueInput
    data: XOR<SolicitudUpdateWithoutCuidadorInput, SolicitudUncheckedUpdateWithoutCuidadorInput>
  }

  export type SolicitudUpdateManyWithWhereWithoutCuidadorInput = {
    where: SolicitudScalarWhereInput
    data: XOR<SolicitudUpdateManyMutationInput, SolicitudUncheckedUpdateManyWithoutSolicitudesInput>
  }

  export type DisponibilidadCreateWithoutServicioInput = {
    id?: string
    fecha_disponible: Date | string
    cuidador: CuidadorCreateNestedOneWithoutDisponibilidadesInput
  }

  export type DisponibilidadUncheckedCreateWithoutServicioInput = {
    id?: string
    cuidador_id: string
    fecha_disponible: Date | string
  }

  export type DisponibilidadCreateOrConnectWithoutServicioInput = {
    where: DisponibilidadWhereUniqueInput
    create: XOR<DisponibilidadCreateWithoutServicioInput, DisponibilidadUncheckedCreateWithoutServicioInput>
  }

  export type DisponibilidadCreateManyServicioInputEnvelope = {
    data: Enumerable<DisponibilidadCreateManyServicioInput>
  }

  export type SolicitudCreateWithoutServicioInput = {
    id?: string
    fecha_solicitada?: Date | string
    estado: string
    fecha_respuesta?: Date | string | null
    usuario: UsuarioCreateNestedOneWithoutSolicitudesInput
    cuidador: CuidadorCreateNestedOneWithoutSolicitudesInput
    comentario?: ComentarioCreateNestedOneWithoutSolicitudInput
    mensajes?: MensajeCreateNestedManyWithoutSolicitudInput
  }

  export type SolicitudUncheckedCreateWithoutServicioInput = {
    id?: string
    usuario_id: string
    cuidador_id: string
    fecha_solicitada?: Date | string
    estado: string
    fecha_respuesta?: Date | string | null
    comentario?: ComentarioUncheckedCreateNestedOneWithoutSolicitudInput
    mensajes?: MensajeUncheckedCreateNestedManyWithoutSolicitudInput
  }

  export type SolicitudCreateOrConnectWithoutServicioInput = {
    where: SolicitudWhereUniqueInput
    create: XOR<SolicitudCreateWithoutServicioInput, SolicitudUncheckedCreateWithoutServicioInput>
  }

  export type SolicitudCreateManyServicioInputEnvelope = {
    data: Enumerable<SolicitudCreateManyServicioInput>
  }

  export type DisponibilidadUpsertWithWhereUniqueWithoutServicioInput = {
    where: DisponibilidadWhereUniqueInput
    update: XOR<DisponibilidadUpdateWithoutServicioInput, DisponibilidadUncheckedUpdateWithoutServicioInput>
    create: XOR<DisponibilidadCreateWithoutServicioInput, DisponibilidadUncheckedCreateWithoutServicioInput>
  }

  export type DisponibilidadUpdateWithWhereUniqueWithoutServicioInput = {
    where: DisponibilidadWhereUniqueInput
    data: XOR<DisponibilidadUpdateWithoutServicioInput, DisponibilidadUncheckedUpdateWithoutServicioInput>
  }

  export type DisponibilidadUpdateManyWithWhereWithoutServicioInput = {
    where: DisponibilidadScalarWhereInput
    data: XOR<DisponibilidadUpdateManyMutationInput, DisponibilidadUncheckedUpdateManyWithoutDisponibilidadesInput>
  }

  export type SolicitudUpsertWithWhereUniqueWithoutServicioInput = {
    where: SolicitudWhereUniqueInput
    update: XOR<SolicitudUpdateWithoutServicioInput, SolicitudUncheckedUpdateWithoutServicioInput>
    create: XOR<SolicitudCreateWithoutServicioInput, SolicitudUncheckedCreateWithoutServicioInput>
  }

  export type SolicitudUpdateWithWhereUniqueWithoutServicioInput = {
    where: SolicitudWhereUniqueInput
    data: XOR<SolicitudUpdateWithoutServicioInput, SolicitudUncheckedUpdateWithoutServicioInput>
  }

  export type SolicitudUpdateManyWithWhereWithoutServicioInput = {
    where: SolicitudScalarWhereInput
    data: XOR<SolicitudUpdateManyMutationInput, SolicitudUncheckedUpdateManyWithoutSolicitudesInput>
  }

  export type CuidadorCreateWithoutDisponibilidadesInput = {
    id?: string
    experiencia?: string | null
    tipo_servicios?: CuidadorCreatetipo_serviciosInput | Enumerable<string>
    calificacion_promedio?: number | null
    cantidad_servicios?: number
    usuario: UsuarioCreateNestedOneWithoutCuidadorInput
    solicitudes?: SolicitudCreateNestedManyWithoutCuidadorInput
  }

  export type CuidadorUncheckedCreateWithoutDisponibilidadesInput = {
    id?: string
    usuario_id: string
    experiencia?: string | null
    tipo_servicios?: CuidadorCreatetipo_serviciosInput | Enumerable<string>
    calificacion_promedio?: number | null
    cantidad_servicios?: number
    solicitudes?: SolicitudUncheckedCreateNestedManyWithoutCuidadorInput
  }

  export type CuidadorCreateOrConnectWithoutDisponibilidadesInput = {
    where: CuidadorWhereUniqueInput
    create: XOR<CuidadorCreateWithoutDisponibilidadesInput, CuidadorUncheckedCreateWithoutDisponibilidadesInput>
  }

  export type ServicioCreateWithoutDisponibilidadesInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    precio_base?: number | null
    solicitudes?: SolicitudCreateNestedManyWithoutServicioInput
  }

  export type ServicioUncheckedCreateWithoutDisponibilidadesInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    precio_base?: number | null
    solicitudes?: SolicitudUncheckedCreateNestedManyWithoutServicioInput
  }

  export type ServicioCreateOrConnectWithoutDisponibilidadesInput = {
    where: ServicioWhereUniqueInput
    create: XOR<ServicioCreateWithoutDisponibilidadesInput, ServicioUncheckedCreateWithoutDisponibilidadesInput>
  }

  export type CuidadorUpsertWithoutDisponibilidadesInput = {
    update: XOR<CuidadorUpdateWithoutDisponibilidadesInput, CuidadorUncheckedUpdateWithoutDisponibilidadesInput>
    create: XOR<CuidadorCreateWithoutDisponibilidadesInput, CuidadorUncheckedCreateWithoutDisponibilidadesInput>
  }

  export type CuidadorUpdateWithoutDisponibilidadesInput = {
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_servicios?: CuidadorUpdatetipo_serviciosInput | Enumerable<string>
    calificacion_promedio?: NullableFloatFieldUpdateOperationsInput | number | null
    cantidad_servicios?: IntFieldUpdateOperationsInput | number
    usuario?: UsuarioUpdateOneRequiredWithoutCuidadorNestedInput
    solicitudes?: SolicitudUpdateManyWithoutCuidadorNestedInput
  }

  export type CuidadorUncheckedUpdateWithoutDisponibilidadesInput = {
    usuario_id?: StringFieldUpdateOperationsInput | string
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_servicios?: CuidadorUpdatetipo_serviciosInput | Enumerable<string>
    calificacion_promedio?: NullableFloatFieldUpdateOperationsInput | number | null
    cantidad_servicios?: IntFieldUpdateOperationsInput | number
    solicitudes?: SolicitudUncheckedUpdateManyWithoutCuidadorNestedInput
  }

  export type ServicioUpsertWithoutDisponibilidadesInput = {
    update: XOR<ServicioUpdateWithoutDisponibilidadesInput, ServicioUncheckedUpdateWithoutDisponibilidadesInput>
    create: XOR<ServicioCreateWithoutDisponibilidadesInput, ServicioUncheckedCreateWithoutDisponibilidadesInput>
  }

  export type ServicioUpdateWithoutDisponibilidadesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio_base?: NullableFloatFieldUpdateOperationsInput | number | null
    solicitudes?: SolicitudUpdateManyWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateWithoutDisponibilidadesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio_base?: NullableFloatFieldUpdateOperationsInput | number | null
    solicitudes?: SolicitudUncheckedUpdateManyWithoutServicioNestedInput
  }

  export type UsuarioCreateWithoutSolicitudesInput = {
    id?: string
    nombre: string
    correo_electronico: string
    contrasena: string
    telefono?: string | null
    direccion?: string | null
    es_cuidador?: boolean
    fecha_registro?: Date | string
    cuidador?: CuidadorCreateNestedOneWithoutUsuarioInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    autenticacion?: AutenticacionCreateNestedManyWithoutUsuarioInput
    mensajes_enviados?: MensajeCreateNestedManyWithoutRemitenteInput
    mensajes_recibidos?: MensajeCreateNestedManyWithoutDestinatarioInput
  }

  export type UsuarioUncheckedCreateWithoutSolicitudesInput = {
    id?: string
    nombre: string
    correo_electronico: string
    contrasena: string
    telefono?: string | null
    direccion?: string | null
    es_cuidador?: boolean
    fecha_registro?: Date | string
    cuidador?: CuidadorUncheckedCreateNestedOneWithoutUsuarioInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    autenticacion?: AutenticacionUncheckedCreateNestedManyWithoutUsuarioInput
    mensajes_enviados?: MensajeUncheckedCreateNestedManyWithoutRemitenteInput
    mensajes_recibidos?: MensajeUncheckedCreateNestedManyWithoutDestinatarioInput
  }

  export type UsuarioCreateOrConnectWithoutSolicitudesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutSolicitudesInput, UsuarioUncheckedCreateWithoutSolicitudesInput>
  }

  export type CuidadorCreateWithoutSolicitudesInput = {
    id?: string
    experiencia?: string | null
    tipo_servicios?: CuidadorCreatetipo_serviciosInput | Enumerable<string>
    calificacion_promedio?: number | null
    cantidad_servicios?: number
    usuario: UsuarioCreateNestedOneWithoutCuidadorInput
    disponibilidades?: DisponibilidadCreateNestedManyWithoutCuidadorInput
  }

  export type CuidadorUncheckedCreateWithoutSolicitudesInput = {
    id?: string
    usuario_id: string
    experiencia?: string | null
    tipo_servicios?: CuidadorCreatetipo_serviciosInput | Enumerable<string>
    calificacion_promedio?: number | null
    cantidad_servicios?: number
    disponibilidades?: DisponibilidadUncheckedCreateNestedManyWithoutCuidadorInput
  }

  export type CuidadorCreateOrConnectWithoutSolicitudesInput = {
    where: CuidadorWhereUniqueInput
    create: XOR<CuidadorCreateWithoutSolicitudesInput, CuidadorUncheckedCreateWithoutSolicitudesInput>
  }

  export type ServicioCreateWithoutSolicitudesInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    precio_base?: number | null
    disponibilidades?: DisponibilidadCreateNestedManyWithoutServicioInput
  }

  export type ServicioUncheckedCreateWithoutSolicitudesInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    precio_base?: number | null
    disponibilidades?: DisponibilidadUncheckedCreateNestedManyWithoutServicioInput
  }

  export type ServicioCreateOrConnectWithoutSolicitudesInput = {
    where: ServicioWhereUniqueInput
    create: XOR<ServicioCreateWithoutSolicitudesInput, ServicioUncheckedCreateWithoutSolicitudesInput>
  }

  export type ComentarioCreateWithoutSolicitudInput = {
    id?: string
    calificacion: number
    comentario?: string | null
    fecha?: Date | string
    usuario: UsuarioCreateNestedOneWithoutComentariosInput
  }

  export type ComentarioUncheckedCreateWithoutSolicitudInput = {
    id?: string
    usuario_id: string
    calificacion: number
    comentario?: string | null
    fecha?: Date | string
  }

  export type ComentarioCreateOrConnectWithoutSolicitudInput = {
    where: ComentarioWhereUniqueInput
    create: XOR<ComentarioCreateWithoutSolicitudInput, ComentarioUncheckedCreateWithoutSolicitudInput>
  }

  export type MensajeCreateWithoutSolicitudInput = {
    id?: string
    contenido: string
    fecha?: Date | string
    remitente: UsuarioCreateNestedOneWithoutMensajes_enviadosInput
    destinatario: UsuarioCreateNestedOneWithoutMensajes_recibidosInput
  }

  export type MensajeUncheckedCreateWithoutSolicitudInput = {
    id?: string
    remitente_id: string
    destinatario_id: string
    contenido: string
    fecha?: Date | string
  }

  export type MensajeCreateOrConnectWithoutSolicitudInput = {
    where: MensajeWhereUniqueInput
    create: XOR<MensajeCreateWithoutSolicitudInput, MensajeUncheckedCreateWithoutSolicitudInput>
  }

  export type MensajeCreateManySolicitudInputEnvelope = {
    data: Enumerable<MensajeCreateManySolicitudInput>
  }

  export type UsuarioUpsertWithoutSolicitudesInput = {
    update: XOR<UsuarioUpdateWithoutSolicitudesInput, UsuarioUncheckedUpdateWithoutSolicitudesInput>
    create: XOR<UsuarioCreateWithoutSolicitudesInput, UsuarioUncheckedCreateWithoutSolicitudesInput>
  }

  export type UsuarioUpdateWithoutSolicitudesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    es_cuidador?: BoolFieldUpdateOperationsInput | boolean
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    cuidador?: CuidadorUpdateOneWithoutUsuarioNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    autenticacion?: AutenticacionUpdateManyWithoutUsuarioNestedInput
    mensajes_enviados?: MensajeUpdateManyWithoutRemitenteNestedInput
    mensajes_recibidos?: MensajeUpdateManyWithoutDestinatarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutSolicitudesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    es_cuidador?: BoolFieldUpdateOperationsInput | boolean
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    cuidador?: CuidadorUncheckedUpdateOneWithoutUsuarioNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    autenticacion?: AutenticacionUncheckedUpdateManyWithoutUsuarioNestedInput
    mensajes_enviados?: MensajeUncheckedUpdateManyWithoutRemitenteNestedInput
    mensajes_recibidos?: MensajeUncheckedUpdateManyWithoutDestinatarioNestedInput
  }

  export type CuidadorUpsertWithoutSolicitudesInput = {
    update: XOR<CuidadorUpdateWithoutSolicitudesInput, CuidadorUncheckedUpdateWithoutSolicitudesInput>
    create: XOR<CuidadorCreateWithoutSolicitudesInput, CuidadorUncheckedCreateWithoutSolicitudesInput>
  }

  export type CuidadorUpdateWithoutSolicitudesInput = {
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_servicios?: CuidadorUpdatetipo_serviciosInput | Enumerable<string>
    calificacion_promedio?: NullableFloatFieldUpdateOperationsInput | number | null
    cantidad_servicios?: IntFieldUpdateOperationsInput | number
    usuario?: UsuarioUpdateOneRequiredWithoutCuidadorNestedInput
    disponibilidades?: DisponibilidadUpdateManyWithoutCuidadorNestedInput
  }

  export type CuidadorUncheckedUpdateWithoutSolicitudesInput = {
    usuario_id?: StringFieldUpdateOperationsInput | string
    experiencia?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_servicios?: CuidadorUpdatetipo_serviciosInput | Enumerable<string>
    calificacion_promedio?: NullableFloatFieldUpdateOperationsInput | number | null
    cantidad_servicios?: IntFieldUpdateOperationsInput | number
    disponibilidades?: DisponibilidadUncheckedUpdateManyWithoutCuidadorNestedInput
  }

  export type ServicioUpsertWithoutSolicitudesInput = {
    update: XOR<ServicioUpdateWithoutSolicitudesInput, ServicioUncheckedUpdateWithoutSolicitudesInput>
    create: XOR<ServicioCreateWithoutSolicitudesInput, ServicioUncheckedCreateWithoutSolicitudesInput>
  }

  export type ServicioUpdateWithoutSolicitudesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio_base?: NullableFloatFieldUpdateOperationsInput | number | null
    disponibilidades?: DisponibilidadUpdateManyWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateWithoutSolicitudesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio_base?: NullableFloatFieldUpdateOperationsInput | number | null
    disponibilidades?: DisponibilidadUncheckedUpdateManyWithoutServicioNestedInput
  }

  export type ComentarioUpsertWithoutSolicitudInput = {
    update: XOR<ComentarioUpdateWithoutSolicitudInput, ComentarioUncheckedUpdateWithoutSolicitudInput>
    create: XOR<ComentarioCreateWithoutSolicitudInput, ComentarioUncheckedCreateWithoutSolicitudInput>
  }

  export type ComentarioUpdateWithoutSolicitudInput = {
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type ComentarioUncheckedUpdateWithoutSolicitudInput = {
    usuario_id?: StringFieldUpdateOperationsInput | string
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MensajeUpsertWithWhereUniqueWithoutSolicitudInput = {
    where: MensajeWhereUniqueInput
    update: XOR<MensajeUpdateWithoutSolicitudInput, MensajeUncheckedUpdateWithoutSolicitudInput>
    create: XOR<MensajeCreateWithoutSolicitudInput, MensajeUncheckedCreateWithoutSolicitudInput>
  }

  export type MensajeUpdateWithWhereUniqueWithoutSolicitudInput = {
    where: MensajeWhereUniqueInput
    data: XOR<MensajeUpdateWithoutSolicitudInput, MensajeUncheckedUpdateWithoutSolicitudInput>
  }

  export type MensajeUpdateManyWithWhereWithoutSolicitudInput = {
    where: MensajeScalarWhereInput
    data: XOR<MensajeUpdateManyMutationInput, MensajeUncheckedUpdateManyWithoutMensajesInput>
  }

  export type SolicitudCreateWithoutComentarioInput = {
    id?: string
    fecha_solicitada?: Date | string
    estado: string
    fecha_respuesta?: Date | string | null
    usuario: UsuarioCreateNestedOneWithoutSolicitudesInput
    cuidador: CuidadorCreateNestedOneWithoutSolicitudesInput
    servicio: ServicioCreateNestedOneWithoutSolicitudesInput
    mensajes?: MensajeCreateNestedManyWithoutSolicitudInput
  }

  export type SolicitudUncheckedCreateWithoutComentarioInput = {
    id?: string
    usuario_id: string
    cuidador_id: string
    servicio_id: string
    fecha_solicitada?: Date | string
    estado: string
    fecha_respuesta?: Date | string | null
    mensajes?: MensajeUncheckedCreateNestedManyWithoutSolicitudInput
  }

  export type SolicitudCreateOrConnectWithoutComentarioInput = {
    where: SolicitudWhereUniqueInput
    create: XOR<SolicitudCreateWithoutComentarioInput, SolicitudUncheckedCreateWithoutComentarioInput>
  }

  export type UsuarioCreateWithoutComentariosInput = {
    id?: string
    nombre: string
    correo_electronico: string
    contrasena: string
    telefono?: string | null
    direccion?: string | null
    es_cuidador?: boolean
    fecha_registro?: Date | string
    cuidador?: CuidadorCreateNestedOneWithoutUsuarioInput
    solicitudes?: SolicitudCreateNestedManyWithoutUsuarioInput
    autenticacion?: AutenticacionCreateNestedManyWithoutUsuarioInput
    mensajes_enviados?: MensajeCreateNestedManyWithoutRemitenteInput
    mensajes_recibidos?: MensajeCreateNestedManyWithoutDestinatarioInput
  }

  export type UsuarioUncheckedCreateWithoutComentariosInput = {
    id?: string
    nombre: string
    correo_electronico: string
    contrasena: string
    telefono?: string | null
    direccion?: string | null
    es_cuidador?: boolean
    fecha_registro?: Date | string
    cuidador?: CuidadorUncheckedCreateNestedOneWithoutUsuarioInput
    solicitudes?: SolicitudUncheckedCreateNestedManyWithoutUsuarioInput
    autenticacion?: AutenticacionUncheckedCreateNestedManyWithoutUsuarioInput
    mensajes_enviados?: MensajeUncheckedCreateNestedManyWithoutRemitenteInput
    mensajes_recibidos?: MensajeUncheckedCreateNestedManyWithoutDestinatarioInput
  }

  export type UsuarioCreateOrConnectWithoutComentariosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutComentariosInput, UsuarioUncheckedCreateWithoutComentariosInput>
  }

  export type SolicitudUpsertWithoutComentarioInput = {
    update: XOR<SolicitudUpdateWithoutComentarioInput, SolicitudUncheckedUpdateWithoutComentarioInput>
    create: XOR<SolicitudCreateWithoutComentarioInput, SolicitudUncheckedCreateWithoutComentarioInput>
  }

  export type SolicitudUpdateWithoutComentarioInput = {
    fecha_solicitada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_respuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuario?: UsuarioUpdateOneRequiredWithoutSolicitudesNestedInput
    cuidador?: CuidadorUpdateOneRequiredWithoutSolicitudesNestedInput
    servicio?: ServicioUpdateOneRequiredWithoutSolicitudesNestedInput
    mensajes?: MensajeUpdateManyWithoutSolicitudNestedInput
  }

  export type SolicitudUncheckedUpdateWithoutComentarioInput = {
    usuario_id?: StringFieldUpdateOperationsInput | string
    cuidador_id?: StringFieldUpdateOperationsInput | string
    servicio_id?: StringFieldUpdateOperationsInput | string
    fecha_solicitada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_respuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mensajes?: MensajeUncheckedUpdateManyWithoutSolicitudNestedInput
  }

  export type UsuarioUpsertWithoutComentariosInput = {
    update: XOR<UsuarioUpdateWithoutComentariosInput, UsuarioUncheckedUpdateWithoutComentariosInput>
    create: XOR<UsuarioCreateWithoutComentariosInput, UsuarioUncheckedCreateWithoutComentariosInput>
  }

  export type UsuarioUpdateWithoutComentariosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    es_cuidador?: BoolFieldUpdateOperationsInput | boolean
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    cuidador?: CuidadorUpdateOneWithoutUsuarioNestedInput
    solicitudes?: SolicitudUpdateManyWithoutUsuarioNestedInput
    autenticacion?: AutenticacionUpdateManyWithoutUsuarioNestedInput
    mensajes_enviados?: MensajeUpdateManyWithoutRemitenteNestedInput
    mensajes_recibidos?: MensajeUpdateManyWithoutDestinatarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutComentariosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    es_cuidador?: BoolFieldUpdateOperationsInput | boolean
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    cuidador?: CuidadorUncheckedUpdateOneWithoutUsuarioNestedInput
    solicitudes?: SolicitudUncheckedUpdateManyWithoutUsuarioNestedInput
    autenticacion?: AutenticacionUncheckedUpdateManyWithoutUsuarioNestedInput
    mensajes_enviados?: MensajeUncheckedUpdateManyWithoutRemitenteNestedInput
    mensajes_recibidos?: MensajeUncheckedUpdateManyWithoutDestinatarioNestedInput
  }

  export type UsuarioCreateWithoutAutenticacionInput = {
    id?: string
    nombre: string
    correo_electronico: string
    contrasena: string
    telefono?: string | null
    direccion?: string | null
    es_cuidador?: boolean
    fecha_registro?: Date | string
    cuidador?: CuidadorCreateNestedOneWithoutUsuarioInput
    solicitudes?: SolicitudCreateNestedManyWithoutUsuarioInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    mensajes_enviados?: MensajeCreateNestedManyWithoutRemitenteInput
    mensajes_recibidos?: MensajeCreateNestedManyWithoutDestinatarioInput
  }

  export type UsuarioUncheckedCreateWithoutAutenticacionInput = {
    id?: string
    nombre: string
    correo_electronico: string
    contrasena: string
    telefono?: string | null
    direccion?: string | null
    es_cuidador?: boolean
    fecha_registro?: Date | string
    cuidador?: CuidadorUncheckedCreateNestedOneWithoutUsuarioInput
    solicitudes?: SolicitudUncheckedCreateNestedManyWithoutUsuarioInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    mensajes_enviados?: MensajeUncheckedCreateNestedManyWithoutRemitenteInput
    mensajes_recibidos?: MensajeUncheckedCreateNestedManyWithoutDestinatarioInput
  }

  export type UsuarioCreateOrConnectWithoutAutenticacionInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutAutenticacionInput, UsuarioUncheckedCreateWithoutAutenticacionInput>
  }

  export type UsuarioUpsertWithoutAutenticacionInput = {
    update: XOR<UsuarioUpdateWithoutAutenticacionInput, UsuarioUncheckedUpdateWithoutAutenticacionInput>
    create: XOR<UsuarioCreateWithoutAutenticacionInput, UsuarioUncheckedCreateWithoutAutenticacionInput>
  }

  export type UsuarioUpdateWithoutAutenticacionInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    es_cuidador?: BoolFieldUpdateOperationsInput | boolean
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    cuidador?: CuidadorUpdateOneWithoutUsuarioNestedInput
    solicitudes?: SolicitudUpdateManyWithoutUsuarioNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    mensajes_enviados?: MensajeUpdateManyWithoutRemitenteNestedInput
    mensajes_recibidos?: MensajeUpdateManyWithoutDestinatarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutAutenticacionInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    es_cuidador?: BoolFieldUpdateOperationsInput | boolean
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    cuidador?: CuidadorUncheckedUpdateOneWithoutUsuarioNestedInput
    solicitudes?: SolicitudUncheckedUpdateManyWithoutUsuarioNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    mensajes_enviados?: MensajeUncheckedUpdateManyWithoutRemitenteNestedInput
    mensajes_recibidos?: MensajeUncheckedUpdateManyWithoutDestinatarioNestedInput
  }

  export type UsuarioCreateWithoutMensajes_enviadosInput = {
    id?: string
    nombre: string
    correo_electronico: string
    contrasena: string
    telefono?: string | null
    direccion?: string | null
    es_cuidador?: boolean
    fecha_registro?: Date | string
    cuidador?: CuidadorCreateNestedOneWithoutUsuarioInput
    solicitudes?: SolicitudCreateNestedManyWithoutUsuarioInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    autenticacion?: AutenticacionCreateNestedManyWithoutUsuarioInput
    mensajes_recibidos?: MensajeCreateNestedManyWithoutDestinatarioInput
  }

  export type UsuarioUncheckedCreateWithoutMensajes_enviadosInput = {
    id?: string
    nombre: string
    correo_electronico: string
    contrasena: string
    telefono?: string | null
    direccion?: string | null
    es_cuidador?: boolean
    fecha_registro?: Date | string
    cuidador?: CuidadorUncheckedCreateNestedOneWithoutUsuarioInput
    solicitudes?: SolicitudUncheckedCreateNestedManyWithoutUsuarioInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    autenticacion?: AutenticacionUncheckedCreateNestedManyWithoutUsuarioInput
    mensajes_recibidos?: MensajeUncheckedCreateNestedManyWithoutDestinatarioInput
  }

  export type UsuarioCreateOrConnectWithoutMensajes_enviadosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutMensajes_enviadosInput, UsuarioUncheckedCreateWithoutMensajes_enviadosInput>
  }

  export type UsuarioCreateWithoutMensajes_recibidosInput = {
    id?: string
    nombre: string
    correo_electronico: string
    contrasena: string
    telefono?: string | null
    direccion?: string | null
    es_cuidador?: boolean
    fecha_registro?: Date | string
    cuidador?: CuidadorCreateNestedOneWithoutUsuarioInput
    solicitudes?: SolicitudCreateNestedManyWithoutUsuarioInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    autenticacion?: AutenticacionCreateNestedManyWithoutUsuarioInput
    mensajes_enviados?: MensajeCreateNestedManyWithoutRemitenteInput
  }

  export type UsuarioUncheckedCreateWithoutMensajes_recibidosInput = {
    id?: string
    nombre: string
    correo_electronico: string
    contrasena: string
    telefono?: string | null
    direccion?: string | null
    es_cuidador?: boolean
    fecha_registro?: Date | string
    cuidador?: CuidadorUncheckedCreateNestedOneWithoutUsuarioInput
    solicitudes?: SolicitudUncheckedCreateNestedManyWithoutUsuarioInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    autenticacion?: AutenticacionUncheckedCreateNestedManyWithoutUsuarioInput
    mensajes_enviados?: MensajeUncheckedCreateNestedManyWithoutRemitenteInput
  }

  export type UsuarioCreateOrConnectWithoutMensajes_recibidosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutMensajes_recibidosInput, UsuarioUncheckedCreateWithoutMensajes_recibidosInput>
  }

  export type SolicitudCreateWithoutMensajesInput = {
    id?: string
    fecha_solicitada?: Date | string
    estado: string
    fecha_respuesta?: Date | string | null
    usuario: UsuarioCreateNestedOneWithoutSolicitudesInput
    cuidador: CuidadorCreateNestedOneWithoutSolicitudesInput
    servicio: ServicioCreateNestedOneWithoutSolicitudesInput
    comentario?: ComentarioCreateNestedOneWithoutSolicitudInput
  }

  export type SolicitudUncheckedCreateWithoutMensajesInput = {
    id?: string
    usuario_id: string
    cuidador_id: string
    servicio_id: string
    fecha_solicitada?: Date | string
    estado: string
    fecha_respuesta?: Date | string | null
    comentario?: ComentarioUncheckedCreateNestedOneWithoutSolicitudInput
  }

  export type SolicitudCreateOrConnectWithoutMensajesInput = {
    where: SolicitudWhereUniqueInput
    create: XOR<SolicitudCreateWithoutMensajesInput, SolicitudUncheckedCreateWithoutMensajesInput>
  }

  export type UsuarioUpsertWithoutMensajes_enviadosInput = {
    update: XOR<UsuarioUpdateWithoutMensajes_enviadosInput, UsuarioUncheckedUpdateWithoutMensajes_enviadosInput>
    create: XOR<UsuarioCreateWithoutMensajes_enviadosInput, UsuarioUncheckedCreateWithoutMensajes_enviadosInput>
  }

  export type UsuarioUpdateWithoutMensajes_enviadosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    es_cuidador?: BoolFieldUpdateOperationsInput | boolean
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    cuidador?: CuidadorUpdateOneWithoutUsuarioNestedInput
    solicitudes?: SolicitudUpdateManyWithoutUsuarioNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    autenticacion?: AutenticacionUpdateManyWithoutUsuarioNestedInput
    mensajes_recibidos?: MensajeUpdateManyWithoutDestinatarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutMensajes_enviadosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    es_cuidador?: BoolFieldUpdateOperationsInput | boolean
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    cuidador?: CuidadorUncheckedUpdateOneWithoutUsuarioNestedInput
    solicitudes?: SolicitudUncheckedUpdateManyWithoutUsuarioNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    autenticacion?: AutenticacionUncheckedUpdateManyWithoutUsuarioNestedInput
    mensajes_recibidos?: MensajeUncheckedUpdateManyWithoutDestinatarioNestedInput
  }

  export type UsuarioUpsertWithoutMensajes_recibidosInput = {
    update: XOR<UsuarioUpdateWithoutMensajes_recibidosInput, UsuarioUncheckedUpdateWithoutMensajes_recibidosInput>
    create: XOR<UsuarioCreateWithoutMensajes_recibidosInput, UsuarioUncheckedCreateWithoutMensajes_recibidosInput>
  }

  export type UsuarioUpdateWithoutMensajes_recibidosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    es_cuidador?: BoolFieldUpdateOperationsInput | boolean
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    cuidador?: CuidadorUpdateOneWithoutUsuarioNestedInput
    solicitudes?: SolicitudUpdateManyWithoutUsuarioNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    autenticacion?: AutenticacionUpdateManyWithoutUsuarioNestedInput
    mensajes_enviados?: MensajeUpdateManyWithoutRemitenteNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutMensajes_recibidosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    es_cuidador?: BoolFieldUpdateOperationsInput | boolean
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    cuidador?: CuidadorUncheckedUpdateOneWithoutUsuarioNestedInput
    solicitudes?: SolicitudUncheckedUpdateManyWithoutUsuarioNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    autenticacion?: AutenticacionUncheckedUpdateManyWithoutUsuarioNestedInput
    mensajes_enviados?: MensajeUncheckedUpdateManyWithoutRemitenteNestedInput
  }

  export type SolicitudUpsertWithoutMensajesInput = {
    update: XOR<SolicitudUpdateWithoutMensajesInput, SolicitudUncheckedUpdateWithoutMensajesInput>
    create: XOR<SolicitudCreateWithoutMensajesInput, SolicitudUncheckedCreateWithoutMensajesInput>
  }

  export type SolicitudUpdateWithoutMensajesInput = {
    fecha_solicitada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_respuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuario?: UsuarioUpdateOneRequiredWithoutSolicitudesNestedInput
    cuidador?: CuidadorUpdateOneRequiredWithoutSolicitudesNestedInput
    servicio?: ServicioUpdateOneRequiredWithoutSolicitudesNestedInput
    comentario?: ComentarioUpdateOneWithoutSolicitudNestedInput
  }

  export type SolicitudUncheckedUpdateWithoutMensajesInput = {
    usuario_id?: StringFieldUpdateOperationsInput | string
    cuidador_id?: StringFieldUpdateOperationsInput | string
    servicio_id?: StringFieldUpdateOperationsInput | string
    fecha_solicitada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_respuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comentario?: ComentarioUncheckedUpdateOneWithoutSolicitudNestedInput
  }

  export type SolicitudCreateManyUsuarioInput = {
    id?: string
    cuidador_id: string
    servicio_id: string
    fecha_solicitada?: Date | string
    estado: string
    fecha_respuesta?: Date | string | null
  }

  export type ComentarioCreateManyUsuarioInput = {
    id?: string
    solicitud_id: string
    calificacion: number
    comentario?: string | null
    fecha?: Date | string
  }

  export type AutenticacionCreateManyUsuarioInput = {
    id?: string
    token: string
    expiracion: Date | string
    tipo: string
  }

  export type MensajeCreateManyRemitenteInput = {
    id?: string
    destinatario_id: string
    contenido: string
    fecha?: Date | string
    solicitud_id?: string | null
  }

  export type MensajeCreateManyDestinatarioInput = {
    id?: string
    remitente_id: string
    contenido: string
    fecha?: Date | string
    solicitud_id?: string | null
  }

  export type SolicitudUpdateWithoutUsuarioInput = {
    fecha_solicitada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_respuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cuidador?: CuidadorUpdateOneRequiredWithoutSolicitudesNestedInput
    servicio?: ServicioUpdateOneRequiredWithoutSolicitudesNestedInput
    comentario?: ComentarioUpdateOneWithoutSolicitudNestedInput
    mensajes?: MensajeUpdateManyWithoutSolicitudNestedInput
  }

  export type SolicitudUncheckedUpdateWithoutUsuarioInput = {
    cuidador_id?: StringFieldUpdateOperationsInput | string
    servicio_id?: StringFieldUpdateOperationsInput | string
    fecha_solicitada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_respuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comentario?: ComentarioUncheckedUpdateOneWithoutSolicitudNestedInput
    mensajes?: MensajeUncheckedUpdateManyWithoutSolicitudNestedInput
  }

  export type SolicitudUncheckedUpdateManyWithoutSolicitudesInput = {
    cuidador_id?: StringFieldUpdateOperationsInput | string
    servicio_id?: StringFieldUpdateOperationsInput | string
    fecha_solicitada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_respuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ComentarioUpdateWithoutUsuarioInput = {
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    solicitud?: SolicitudUpdateOneRequiredWithoutComentarioNestedInput
  }

  export type ComentarioUncheckedUpdateWithoutUsuarioInput = {
    solicitud_id?: StringFieldUpdateOperationsInput | string
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentarioUncheckedUpdateManyWithoutComentariosInput = {
    solicitud_id?: StringFieldUpdateOperationsInput | string
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutenticacionUpdateWithoutUsuarioInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type AutenticacionUncheckedUpdateWithoutUsuarioInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type AutenticacionUncheckedUpdateManyWithoutAutenticacionInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type MensajeUpdateWithoutRemitenteInput = {
    contenido?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    destinatario?: UsuarioUpdateOneRequiredWithoutMensajes_recibidosNestedInput
    solicitud?: SolicitudUpdateOneWithoutMensajesNestedInput
  }

  export type MensajeUncheckedUpdateWithoutRemitenteInput = {
    destinatario_id?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    solicitud_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MensajeUncheckedUpdateManyWithoutMensajes_enviadosInput = {
    destinatario_id?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    solicitud_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MensajeUpdateWithoutDestinatarioInput = {
    contenido?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    remitente?: UsuarioUpdateOneRequiredWithoutMensajes_enviadosNestedInput
    solicitud?: SolicitudUpdateOneWithoutMensajesNestedInput
  }

  export type MensajeUncheckedUpdateWithoutDestinatarioInput = {
    remitente_id?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    solicitud_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MensajeUncheckedUpdateManyWithoutMensajes_recibidosInput = {
    remitente_id?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    solicitud_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DisponibilidadCreateManyCuidadorInput = {
    id?: string
    fecha_disponible: Date | string
    servicio_id: string
  }

  export type SolicitudCreateManyCuidadorInput = {
    id?: string
    usuario_id: string
    servicio_id: string
    fecha_solicitada?: Date | string
    estado: string
    fecha_respuesta?: Date | string | null
  }

  export type DisponibilidadUpdateWithoutCuidadorInput = {
    fecha_disponible?: DateTimeFieldUpdateOperationsInput | Date | string
    servicio?: ServicioUpdateOneRequiredWithoutDisponibilidadesNestedInput
  }

  export type DisponibilidadUncheckedUpdateWithoutCuidadorInput = {
    fecha_disponible?: DateTimeFieldUpdateOperationsInput | Date | string
    servicio_id?: StringFieldUpdateOperationsInput | string
  }

  export type DisponibilidadUncheckedUpdateManyWithoutDisponibilidadesInput = {
    fecha_disponible?: DateTimeFieldUpdateOperationsInput | Date | string
    servicio_id?: StringFieldUpdateOperationsInput | string
  }

  export type SolicitudUpdateWithoutCuidadorInput = {
    fecha_solicitada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_respuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuario?: UsuarioUpdateOneRequiredWithoutSolicitudesNestedInput
    servicio?: ServicioUpdateOneRequiredWithoutSolicitudesNestedInput
    comentario?: ComentarioUpdateOneWithoutSolicitudNestedInput
    mensajes?: MensajeUpdateManyWithoutSolicitudNestedInput
  }

  export type SolicitudUncheckedUpdateWithoutCuidadorInput = {
    usuario_id?: StringFieldUpdateOperationsInput | string
    servicio_id?: StringFieldUpdateOperationsInput | string
    fecha_solicitada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_respuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comentario?: ComentarioUncheckedUpdateOneWithoutSolicitudNestedInput
    mensajes?: MensajeUncheckedUpdateManyWithoutSolicitudNestedInput
  }

  export type DisponibilidadCreateManyServicioInput = {
    id?: string
    cuidador_id: string
    fecha_disponible: Date | string
  }

  export type SolicitudCreateManyServicioInput = {
    id?: string
    usuario_id: string
    cuidador_id: string
    fecha_solicitada?: Date | string
    estado: string
    fecha_respuesta?: Date | string | null
  }

  export type DisponibilidadUpdateWithoutServicioInput = {
    fecha_disponible?: DateTimeFieldUpdateOperationsInput | Date | string
    cuidador?: CuidadorUpdateOneRequiredWithoutDisponibilidadesNestedInput
  }

  export type DisponibilidadUncheckedUpdateWithoutServicioInput = {
    cuidador_id?: StringFieldUpdateOperationsInput | string
    fecha_disponible?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SolicitudUpdateWithoutServicioInput = {
    fecha_solicitada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_respuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuario?: UsuarioUpdateOneRequiredWithoutSolicitudesNestedInput
    cuidador?: CuidadorUpdateOneRequiredWithoutSolicitudesNestedInput
    comentario?: ComentarioUpdateOneWithoutSolicitudNestedInput
    mensajes?: MensajeUpdateManyWithoutSolicitudNestedInput
  }

  export type SolicitudUncheckedUpdateWithoutServicioInput = {
    usuario_id?: StringFieldUpdateOperationsInput | string
    cuidador_id?: StringFieldUpdateOperationsInput | string
    fecha_solicitada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_respuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comentario?: ComentarioUncheckedUpdateOneWithoutSolicitudNestedInput
    mensajes?: MensajeUncheckedUpdateManyWithoutSolicitudNestedInput
  }

  export type MensajeCreateManySolicitudInput = {
    id?: string
    remitente_id: string
    destinatario_id: string
    contenido: string
    fecha?: Date | string
  }

  export type MensajeUpdateWithoutSolicitudInput = {
    contenido?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    remitente?: UsuarioUpdateOneRequiredWithoutMensajes_enviadosNestedInput
    destinatario?: UsuarioUpdateOneRequiredWithoutMensajes_recibidosNestedInput
  }

  export type MensajeUncheckedUpdateWithoutSolicitudInput = {
    remitente_id?: StringFieldUpdateOperationsInput | string
    destinatario_id?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MensajeUncheckedUpdateManyWithoutMensajesInput = {
    remitente_id?: StringFieldUpdateOperationsInput | string
    destinatario_id?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}